{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"目录 内容提要 第一部分 小试牛刀 第1章——探索Scala 第2章——体验Scala 第3章——从Java到Scala 第4章——善用对象 第5章——善用类型 第二部分 深入 Scala 第6章——函数值和闭包 第7章——特质 第8章——集合 第9章——模式匹配和正则表达式 第10章——处理异常 第11章——递归编程 第三部分 Scala 中的并发编程 第12章——惰性求值和并行集合 第13章——使用Actor编程 第四部分 Scala 实战 第14章——和Java进行互操作 第15章——使用Scala创建应用程序 第16章——单元测试 参考书目 额外指引 勘误\n《Scala 实用指南》\n一本写给Java开发者的Scala快速入门书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/abstract.html","text":"","title":"内容提要 ·"},{"location":"/abstract.html#内容提要","text":"本书是为想要快速学习或者正在学习 Scala 编程语言的 Java 开发者写的，循序渐进地介 绍了 Scala 编程语言的多个方面。\n本书共分为 4 个部分：第一部分详细介绍 Scala 的一些基础知识，并和 Java 中的相关概 念进行了参照，方便读者快速上手 Scala；第二部分进一步介绍 Scala 的一些中级知识，以及 与 Java 的一些差异点，方便读者编写出更简洁的代码；第三部分介绍在 Scala 中如何进行并 发编程，并务实地介绍 Akka 套件；第四部分通过实战练习对前面的知识进行综合应用，并 系统地介绍如何与 Java 进行互操作。此外，附录部分还包括一些额外指引。\n本书的目标读者是对 JVM 平台上的语言以及函数式编程感兴趣的程序员。阅读本书不需 要读者熟悉 Scala 编程语言，但需要读者具备 Java、面向对象编程的背景知识。因为本书以 一种非常务实的方式组织内容，所以读者无法学到 Scala 的所有内容，但是足以应付日常工 作，如果想要更全面地学习 Scala 以及其背后的一些设计理念，则最好辅以其他图书。","title":"内容提要"},{"location":"/part1.html","text":"","title":"第一部分 小试牛刀 ·"},{"location":"/part1.html#第一部分-小试牛刀","text":"本书的第一部分将帮助 Java 程序员更加容易地适应 Scala，读者将了解：\nScala 提供了什么； 如何创建类、元组等； 如何使用 REPL； Scala 和 Java 之间有哪些差异； 类型和类型推断。","title":"第一部分 小试牛刀"},{"location":"/chapter-01/index.html","text":"","title":"第1章——探索Scala ·"},{"location":"/chapter-01/index.html#第1章-探索scala","text":"Scala 是一门强大的编程语言：不需要牺牲强大的静态类型检查支持，就可以写出富有表 现力而又简洁的代码。","title":"第1章——探索Scala"},{"location":"/chapter-01/index.html#1-2-以少胜多","text":"Introduction/TopStock.scala\nval symbols = List(\"AMD\", \"AAPL\", \"AMZN\", \"IBM\", \"ORCL\", \"MSFT\")\nval year = 2017\n\nval (topStock, topPrice) =\n  symbols\n    .map { ticker =>\n      (ticker, getYearEndClosingPrice(ticker, year))\n    }\n    .maxBy { stockPrice =>\n      stockPrice._2\n    }\n\nprintf(s\"Top stock of $year is $topStock closing at price $$$topPrice\")\nIntroduction/TopStock.scala\ncase class Record(year: Int, month: Int, date: Int, closePrice: BigDecimal)\n\ndef getYearEndClosingPrice(symbol: String, year: Int): BigDecimal = {\n  val url = s\"https://raw.githubusercontent.com/ReactivePlatform/\" +\n    s\"Pragmatic-Scala-StaticResources/master/src/main/resources/\" +\n    s\"stocks/daily/daily_$symbol.csv\"\n\n  val data = io.Source.fromURL(url).mkString\n  val maxClosePrize = data\n    .split(\"\\n\")\n    .filter(record => record.startsWith(s\"$year-12\"))\n    .map(record => {\n      val Array(timestamp, open, high, low, close, volume) = record.split(\",\")\n      val Array(year, month, date) = timestamp.split(\"-\")\n      Record(year.toInt, month.toInt, date.toInt, BigDecimal(close.trim))\n    })\n    .sortBy(_.date)(Ordering[Int].reverse)\n    .take(1)\n    .map(_.closePrice)\n    .head\n  maxClosePrize\n}\n运行结果\nTop stock of 2017 is AMZN closing at price $1169.4700\nIntroduction/FastTopStock.scala\nimport scala.collection.parallel.CollectionConverters._\nval (topStock, topPrice) =\n  symbols.par\n    .map { ticker =>\n      (ticker, getYearEndClosingPrice(ticker, year))\n    }\n    .maxBy { stockPrice =>\n      stockPrice._2\n    }\n编译sample.scala的结果\nsample.scala:2:\nerror: type mismatch;\n found   : String(\"haha\")\n required: Int\ni = \"haha\" //Error\n    ^\none error found","title":"1.2 以少胜多"},{"location":"/chapter-01/index.html#1-3-函数式编程","text":"Introduction/FindMax.java\npublic static int findMax(List<Integer> temperatures) {\n     //Java code\n  int highTemperature = Integer.MIN_VALUE;\n  for(int temperature : temperatures) {\n   highTemperature = Math.max(highTemperature, temperature);\n  }\n  return highTemperature;\n}\nIntroduction/FindMaxImperative.scala\ndef findMax(temperatures: List[Int]) = {\n  var highTemperature = Integer.MIN_VALUE\n  for (temperature <- temperatures) {\n    highTemperature = Math.max(highTemperature, temperature)\n  }\n  highTemperature\n}\nIntroduction/FindMaxFunctional.scala\ndef findMax(temperatures: List[Int]) = {\n  temperatures.foldLeft(Integer.MIN_VALUE) { Math.max }\n}\nIntroduction/ScalaDoubleValues.scala\nval values = List(1, 2, 3, 4, 5)\n\nval doubleValues = values.map(_ * 2)","title":"1.3 函数式编程"},{"location":"/chapter-02/index.html","text":"","title":"第2章——体验Scala ·"},{"location":"/chapter-02/index.html#第2章-体验scala","text":"令人惊喜的是，无论是创建一个简短的脚本还是一个完整的企业级应用，都可以轻松地 用 Scala 代码实现并运行。你可以使用任何 IDE，也可以只使用轻量级的编辑器。","title":"第2章——体验Scala"},{"location":"/chapter-02/index.html#2-1-使用-repl","text":"Welcome to Scala 2.12.6 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_172).\nType in expressions for evaluation. Or try :help.\n\nscala>\nscala> val number = 6\nnumber: Int = 6\nscala> number = 7\n<console>:11: error: reassignment to val\n       number = 7\n              ^\nscala> val number = 7\nnumber: Int = 7\nscala> val list = List(1, 2, 3)\nlist: List[Int] = List(1, 2, 3)\nscala> def isPalindrome(str: String) =\n     |   str == str.reverse\nisPalindrome: (str: String)Boolean\n\nscala> isPalindrome(\"mom\")\nres0: Boolean = true\n\nscala> isPalindrome(\"dude\")\nres1: Boolean = false\n\nscala> :quit","title":"2.1 使用 REPL"},{"location":"/chapter-02/index.html#2-2-命令行上的-scala","text":"println(\"Hello World, Welcome to Scala\")\n运行结果\n>scala HelloWorld.scala\nHello World, Welcome to Scala","title":"2.2 命令行上的 Scala"},{"location":"/chapter-02/index.html#2-3-以独立脚本方式运行-scala-代码","text":"#!/usr/bin/env scala\n\n// #snip\nprintln(\"Hello \" + args(0))\n// #snip\n运行命令\nhello.sh Buddy\n运行结果\nHello Buddy\n// #snip\necho off\n\ncls\ncall scala %1\npause\n// #snip","title":"2.3 以独立脚本方式运行 Scala 代码"},{"location":"/chapter-02/index.html#2-4-编译-scala","text":"FirstStep/Sample.scala\nobject Sample extends App {\n  println(\"Hello Scala\")\n}\n运行结果\n> scalac Sample.scala\n> scala Sample\nHello Scala\n> java -classpath /opt/scala/current/lib/scala-library.jar:. Sample\nHello Scala","title":"2.4 编译 Scala"},{"location":"/chapter-03/index.html","text":"","title":"第3章——从Java到Scala ·"},{"location":"/chapter-03/index.html#第3章-从java到scala","text":"你可以在使用 Scala 的同时运用自己的 Java 技能。在某些方面 Scala 与 Java 类似，但在 许多其他方面又彼此不同。Scala 青睐纯面向对象，但它又尽可能将类型和 Java 的类型对应 起来。Scala 在支持熟悉的命令式编程风格的同时，也支持函数式编程风格。因此，你可以使 用最熟悉的风格立即开始编程，而不用承受陡峭的学习曲线。","title":"第3章——从Java到Scala"},{"location":"/chapter-03/index.html#3-1-scala-简洁的-java","text":"FromJavaToScala/Greetings.java\n//Java code\npublic class Greetings {\n  public static void main(String[] args) {\n    for(int i = 1; i < 4; i++) {\n      System.out.print(i + \",\");     \n    } \n    System.out.println(\"Scala Rocks!!!\");\n  }\n}\n运行结果\n1,2,3,Scala Rocks!!!\nFromJavaToScala/Greet.scala\nfor (i <- 1 to 3) {\n  print(s\"$i,\")\n}\n\nprintln(\"Scala Rocks!!!\")\n运行结果\nFromJavaToScala/Greet.scala\n1,2,3,Scala Rocks!!!\nFromJavaToScala/GreetExclusiveUpper.scala\nfor (i <- 1 until 3) {\n  print(s\"$i,\")\n}\n\nprintln(\"Scala Rocks!!!\")\n运行结果\n1,2,Scala Rocks!!!\nFromJavaToScala/GreetForEach.scala\n(1 to 3).foreach(i => print(s\"$i,\"))\n\nprintln(\"Scala Rocks!!!\")\n运行结果\n1,2,3,Scala Rocks!!!","title":"3.1 Scala：简洁的 Java"},{"location":"/chapter-03/index.html#3-2-java-原始类型对应的-scala-类","text":"FromJavaToScala/ScalaInt.scala\nclass ScalaInt {\n  def playWithInt(): Unit = {\n    val capacity: Int = 10\n    val list = new java.util.ArrayList[String]\n    list.ensureCapacity(capacity)\n  }\n}","title":"3.2 Java 原始类型对应的 Scala 类"},{"location":"/chapter-03/index.html#3-3-元组和多重赋值","text":"FromJavaToScala/MultipleAssignment.scala\ndef getPersonInfo(primaryKey: Int) = {\n  // Assume primaryKey is used to fetch a person's info...\n  // Here response is hard-coded\n  (\"Venkat\", \"Subramaniam\", \"venkats@agiledeveloper.com\")\n}\n\nval (firstName, lastName, emailAddress) = getPersonInfo(1)\n\nprintln(s\"First Name: $firstName\")\nprintln(s\"Last Name: $lastName\")\nprintln(s\"Email Address: $emailAddress\")\n运行结果\nFirst Name: Venkat\nLast Name: Subramaniam\nEmail Address: venkats@agiledeveloper.com\nFromJavaToScala/MultipleAssignment2.scala\ndef getPersonInfo(primaryKey: Int): (String, String, String) = {\n  (\"Venkat\", \"Subramaniam\", \"venkats@agiledeveloper.com\")\n}\n\nval (firstName, lastName) = getPersonInfo(1)\n运行结果\nMultipleAssignment2.scala:5: error: constructor cannot be instantiated to\nexpected type;\n found   : (T1, T2)\n required: (String, String, String)\nval (firstName, lastName) = getPersonInfo(1)\n    ^\none error found","title":"3.3 元组和多重赋值"},{"location":"/chapter-03/index.html#3-4-灵活的参数和参数值","text":"FromJavaToScala/Parameters.scala\ndef max(values: Int*) = values.foldLeft(values(0)) { Math.max }\nFromJavaToScala/Parameters.scala\nmax(8, 2, 3)\nFromJavaToScala/Parameters.scala\nmax(2, 5, 3, 7, 1, 6)\nFromJavaToScala/ArgType.scala\ndef function(input: Int*): Unit = println(input.getClass)\n\nfunction(1, 2, 3)\n运行结果\nclass scala.collection.mutable.WrappedArray$ofInt\nFromJavaToScala/CantSendArray.scala\nval numbers = Array(2, 5, 3, 7, 1, 6)\nmax(numbers) // type mismatch error\n运行结果\nCantSendArray.scala:5: error: type mismatch;\n found   : Array[Int]\n required: Int\nmax(numbers) // type mismatch error\n    ^\none error found\nFromJavaToScala/Parameters.scala\nval numbers = Array(2, 5, 3, 7, 1, 6)\nmax(numbers: _*)\nFromJavaToScala/DefaultValues.scala\ndef mail(destination: String = \"head office\", mailClass: String = \"first\"): Unit =\n  println(s\"sending to $destination by $mailClass class\")\nFromJavaToScala/DefaultValues.scala\nmail(\"Houston office\", \"Priority\")\nmail(\"Boston office\")\nmail()\n运行结果\nsending to Houston office by Priority class\nsending to Boston office by first class\nsending to head office by first class\nFromJavaToScala/Named.scala\nmail(mailClass = \"Priority\", destination = \"Bahamas office\")\nFromJavaToScala/Named.scala\nmail(mailClass = \"Priority\")","title":"3.4 灵活的参数和参数值"},{"location":"/chapter-03/index.html#3-5-隐式参数","text":"FromJavaToScala/ImplicitParameters.scala\nclass Wifi(name: String) {\n  override def toString: String = name\n}\n\ndef connectToNetwork(user: String)(implicit wifi: Wifi): Unit = {\n  println(s\"User: $user connected to WIFI $wifi\")\n}\n\ndef atOffice(): Unit = {\n  println(\"--- at the office ---\")\n  implicit def officeNetwork: Wifi = new Wifi(\"office-network\")\n  val cafeteriaNetwork = new Wifi(\"cafe-connect\")\n\n  connectToNetwork(\"guest\")(cafeteriaNetwork)\n  connectToNetwork(\"Jill Coder\")\n  connectToNetwork(\"Joe Hacker\")\n}\n\ndef atJoesHome(): Unit = {\n  println(\"--- at Joe's home ---\")\n  implicit def homeNetwork: Wifi = new Wifi(\"home-network\")\n\n  connectToNetwork(\"guest\")(homeNetwork)\n  connectToNetwork(\"Joe Hacker\")\n}\n\natOffice()\natJoesHome()\n运行结果\n--- at the office ---\nUser: guest connected to WIFI cafe-connect\nUser: Jill Coder connected to WIFI office-network\nUser: Joe Hacker connected to WIFI office-network\n--- at Joe's home ---\nUser: guest connected to WIFI home-network\nUser: Joe Hacker connected to WIFI home-network","title":"3.5 隐式参数"},{"location":"/chapter-03/index.html#3-6-字符串和多行原始字符串","text":"FromJavaToScala/MultiLine.scala\nval str = \"\"\"In his famous inaugural speech, John F. Kennedy said\n        \"And so, my fellow Americans: ask not what your country can do\n\tfor you-ask what you can do for your country.\" He then proceeded\n\tto speak to the citizens of the World...\"\"\"\n  println(str)\n运行结果\nIn his famous inaugural speech, John F. Kennedy said\n        \"And so, my fellow Americans: ask not what your country can do \n\tfor you-ask what you can do for your country.\" He then proceeded \n\tto speak to the citizens of the World...\nFromJavaToScala/MultiLine2.scala\nval str = \"\"\"In his famous inaugural speech, John F. Kennedy said\n            \t|\"And so, my fellow Americans: ask not what your country can do\n            \t|for you-ask what you can do for your country.\" He then proceeded\n            \t|to speak to the citizens of the World...\"\"\".stripMargin\nprintln(str)\n运行结果\nIn his famous inaugural speech, John F. Kennedy said\n\"And so, my fellow Americans: ask not what your country can do \nfor you-ask what you can do for your country.\" He then proceeded \nto speak to the citizens of the World...\nFromJavaToScala/StringInterpolation.scala\nval message = s\"A discount of $discount% has been applied\"\nFromJavaToScala/StringInterpolation.scala\nvar price = 90\nval totalPrice = s\"The amount of discount is ${price * discount / 100} dollars\"\nFromJavaToScala/StringInterpolation.scala\nval totalPrice = s\"The amount of discount is $$${price * discount / 100}\"\nFromJavaToScala/StringInterpolation.scala\nval discount = 10\nvar price = 100\nval totalPrice =\n  s\"The amount after discount is $$${price * (1 - discount / 100.0)}\"\nprintln(totalPrice)\n\nprice = 50\nprintln(totalPrice)\n运行结果\nThe amount after discount is $90.0\nThe amount after discount is $90.0\nFromJavaToScala/StringInterpolation.scala\nval product = \"ticket\"\nval price = 25.12\nval discount = 10\nprintln(s\"On $product $discount% saves $$${price * discount / 100.00}\")\n运行结果\nOn ticket 10% saves $2.512","title":"3.6 字符串和多行原始字符串"},{"location":"/chapter-03/index.html#3-9-操作符重载","text":"FromJavaToScala/Complex.scala\nclass Complex(val real: Int, val imaginary: Int) {\n  def +(operand: Complex): Complex = {\n    new Complex(real + operand.real, imaginary + operand.imaginary)\n  }\n\n  override def toString: String = {\n    val sign = if (imaginary < 0) \"\" else \"+\"\n    s\"$real$sign${imaginary}i\"\n  }\n}\n\nval c1 = new Complex(1, 2)\nval c2 = new Complex(2, -3)\nval sum = c1 + c2\nprintln(s\"($c1) + ($c2) = $sum\")\n运行结果\n(1+2i) + (2-3i) = 3-1i\nFromJavaToScala/Complex2.scala\nclass Complex(val real: Int, val imaginary: Int) {\n  def +(operand: Complex): Complex = {\n    println(\"Calling +\")\n    new Complex(real + operand.real, imaginary + operand.imaginary)\n  }\n\n  def *(operand: Complex): Complex = {\n    println(\"Calling *\")\n    new Complex(\n      real * operand.real - imaginary * operand.imaginary,\n      real * operand.imaginary + imaginary * operand.real)\n  }\n  override def toString: String = {\n    val sign = if (imaginary < 0) \"\" else \"+\"\n    s\"$real$sign${imaginary}i\"\n  }\n}\n\nval c1 = new Complex(1, 4)\nval c2 = new Complex(2, -3)\nval c3 = new Complex(2, 2)\nprintln(c1 + c2 * c3)\n运行结果\nCalling *\nCalling +\n11+2i","title":"3.9 操作符重载"},{"location":"/chapter-03/index.html#3-10-scala-与-java-的差异","text":"FromJavaToScala/SerialAssignments.scala\nvar a = 1\nvar b = 2\na = b = 3 //Error\n运行结果\nSerialAssignments.scala:4: error: type mismatch;\n found   : Unit\n required: Int\na = b = 3\n      ^\none error found\nFromJavaToScala/Equality.scala\nval str1 = \"hello\"\nval str2 = \"hello\"\nval str3 = new String(\"hello\")\n\nprintln(str1 == str2) // Equivalent to Java's str1.equals(str2)\nprintln(str1 eq str2) // Equivalent to Java's str1 == str2\nprintln(str1 == str3)\nprintln(str1 eq str3)\n运行结果\ntrue\ntrue\ntrue\nfalse\nFromJavaToScala/OptionalSemicolon.scala\nval list1 = new java.util.ArrayList[Int];\n{\n  println(\"Created list1\")\n}\n\nval list2 = new java.util.ArrayList[Int] {\n  println(\"Created list2\")\n}\n\nprintln(list1.getClass)\nprintln(list2.getClass)\n运行结果\nCreated list1\nCreated list2\nclass java.util.ArrayList\nclass Main$$anon$2$$anon$1\nFromJavaToScala/AvoidExplicitReturn.scala\ndef check1 = true\ndef check2: Boolean = return true\ndef check3: Boolean = true\nprintln(check1)\nprintln(check2)\nprintln(check3)\n运行结果\ntrue\ntrue\ntrue","title":"3.10 Scala 与 Java 的差异"},{"location":"/chapter-03/index.html#3-11-默认访问修饰符","text":"FromJavaToScala/Access.scala\nclass Microwave {\n  def start(): Unit = println(\"started\")\n  def stop(): Unit = println(\"stopped\")\n  private def turnTable(): Unit = println(\"turning table\")\n}\nval microwave = new Microwave\nmicrowave.start() // OK\n运行结果\nAccess.scala:9: error: method turnTable in class Microwave cannot be\naccessed in this.Microwave\nmicrowave.turnTable() //ERROR\n          ^\none error found\nFromJavaToScala/Protected.scala\nclass Vehicle {\n  protected def checkEngine() {}\n}\n\nclass Car extends Vehicle {\n  def start() { checkEngine() /*OK*/ }\n  def tow(car: Car) {\n    car.checkEngine() //OK\n  }\n  def tow(vehicle: Vehicle) {\n    vehicle.checkEngine() //ERROR\n  }\n}\n\nclass GasStation {\n  def fillGas(vehicle: Vehicle) {\n    vehicle.checkEngine() //ERROR\n  }\n}\n运行结果\nProtected.scala:12: error: method checkEngine in class Vehicle cannot be\naccessed in automobiles.Vehicle\n Access to protected method checkEngine not permitted because\n prefix type automobiles.Vehicle does not conform to\n class Car in package automobiles where the access take place\n    vehicle.checkEngine() //ERROR\n            ^\nProtected.scala:17: error: method checkEngine in class Vehicle cannot be \naccessed in automobiles.Vehicle\n Access to protected method checkEngine not permitted because\n enclosing class GasStation in package automobiles is not a subclass of\n class Vehicle in package automobiles where target is defined\n    vehicle.checkEngine() //ERROR\n            ^\ntwo errors found\nFromJavaToScala/FineGrainedAccessControl.scala\npackage society {\n\n  package professional {\n    class Executive {\n      private[professional] var workDetails = null\n      private[society] var friends = null\n      private[this] var secrets = null\n\n      def help(another: Executive): Unit = {\n        println(another.workDetails)\n        println(secrets)\n        println(another.secrets) //ERROR\n      }\n    }\n\n    class Assistant {\n      def assist(anExec: Executive): Unit = {\n        println(anExec.workDetails)\n        println(anExec.friends)\n      }\n    }\n  }\n\n  package social {\n    class Acquaintance {\n      def socialize(person: professional.Executive) {\n        println(person.friends)\n        println(person.workDetails) // ERROR\n      }\n    }\n  }\n}\n运行结果\nFineGrainedAccessControl.scala:12: error: value secrets is not a member of\nsociety.professional.Executive\n        println(another.secrets) //ERROR\n                        ^\nFineGrainedAccessControl.scala:28: error: variable workDetails in class \nExecutive cannot be accessed in society.professional.Executive\n        println(person.workDetails) // ERROR\n                       ^\ntwo errors found","title":"3.11 默认访问修饰符"},{"location":"/chapter-04/index.html","text":"","title":"第4章——善用对象 ·"},{"location":"/chapter-04/index.html#第4章-善用对象","text":"Scala 是一门完全面向对象的编程语言，为类的创建和对象的处理提供了简洁的语法。 Java 中能做的，在 Scala 中都可以做，Scala 还额外提供了一些更强大的特性，以帮助我们进 行面向对象编程。尽管 Scala 是一门纯面向对象的编程语言，但是它也支持一些 Java 中不是 那么纯粹的面向对象概念，如静态方法 ① 。利用伴生对象，Scala 以一种相当有趣的方式处理 了这个问题。伴生对象是伴随一个类的单例，在 Scala 中非常常见。","title":"第4章——善用对象"},{"location":"/chapter-04/index.html#4-1-创建并使用类","text":"WorkingWithObjects/Car.java\n//Java example\npublic class Car {\n  private final int year;\n  private int miles;    \n  \n  public Car(int yearOfMake) { year = yearOfMake; }\n  \n  public int getYear() { return year; }\n  public int getMiles() { return miles; }\n  \n  public void drive(int distance) {                   \n    miles += Math.abs(distance);\n  }\n}\nWorkingWithObjects/UseCar.scala\nclass Car(val year: Int) {\n  private var milesDriven: Int = 0\n\n  def miles: Int = milesDriven\n\n  def drive(distance: Int): Unit = {\n    milesDriven += Math.abs(distance)\n  }\n}\n运行结果\nCar made in year 2015\nMiles driven 0\nDrive for 10 miles\nMiles driven 10\nWorkingWithObjects/CreditCard.scala\nclass CreditCard(val number: Int, var creditLimit: Int)\n运行结果\nCompiled from \"CreditCard.scala\"\npublic class CreditCard {\n  private final int number;\n  private int creditLimit;\n  public int number();\n  public int creditLimit();\n  public void creditLimit_$eq(int);\n  public CreditCard(int, int);\n}\nWorkingWithObjects/Construct.scala\nclass Construct(param: String) {\n  println(s\"Creating an instance of Construct with parameter $param\")\n}\n\nprintln(\"Let's create an instance\")\nnew Construct(\"sample\")\n运行结果\nLet's create an instance\nCreating an instance of Construct with parameter sample\nWorkingWithObjects/Person.scala\nclass Person(val firstName: String, val lastName: String) {\n  var position: String = _\n\n  println(s\"Creating $toString\")\n\n  def this(firstName: String, lastName: String, positionHeld: String) {\n    this(firstName, lastName)\n    position = positionHeld\n  }\n  override def toString: String = {\n    s\"$firstName $lastName holds $position position\"\n  }\n}\n\nval john = new Person(\"John\", \"Smith\", \"Analyst\")\nprintln(john)\nval bill = new Person(\"Bill\", \"Walker\")\nprintln(bill)\n运行结果\nCreating John Smith holds null position\nJohn Smith holds Analyst position\nCreating Bill Walker holds null position\nBill Walker holds null position\n反编译结果\nprivate java.lang.String position;\npublic java.lang.String position();\npublic void position_$eq(java.lang.String);","title":"4.1 创建并使用类"},{"location":"/chapter-04/index.html#4-2-遵循-javabean-惯例","text":"WorkingWithObjects/Dude.scala\nimport scala.beans.BeanProperty\n\nclass Dude(@BeanProperty val firstName: String, val lastName: String) {\n  @BeanProperty var position: String = _\n}\n反编译结果\nCompiled from \"Dude.scala\"\npublic class Dude {\n  private final java.lang.String firstName;\n  private final java.lang.String lastName;\n  private java.lang.String position;\n  public java.lang.String firstName();\n  public java.lang.String lastName();\n  public java.lang.String position();\n  public void position_$eq(java.lang.String);\n  public void setPosition(java.lang.String);\n  public java.lang.String getFirstName();\n  public java.lang.String getPosition();\n  public Dude(java.lang.String, java.lang.String);\n}","title":"4.2 遵循 JavaBean 惯例"},{"location":"/chapter-04/index.html#4-3-类型别名","text":"WorkingWithObjects/PoliceOfficer.scala\nclass PoliceOfficer(val name: String)\nWorkingWithObjects/CopApp.scala\nobject CopApp extends App {\n  type Cop = PoliceOfficer\n\n  val topCop = new Cop(\"Jack\")\n  println(topCop.getClass)\n}\n运行结果\nclass PoliceOfficer","title":"4.3 类型别名"},{"location":"/chapter-04/index.html#4-4-扩展一个类","text":"WorkingWithObjects/Vehicle.scala\nclass Vehicle(val id: Int, val year: Int) {\n  override def toString = s\"ID: $id Year: $year\"\n}\n\nclass Car(override val id: Int, override val year: Int, var fuelLevel: Int) extends Vehicle(id, year) {\n  override def toString = s\"${super.toString} Fuel Level: $fuelLevel\"\n}\n\nval car = new Car(1, 2015, 100)\nprintln(car)\n运行结果\nID: 1 Year: 2015 Fuel Level: 100","title":"4.4 扩展一个类"},{"location":"/chapter-04/index.html#4-5-参数化类型","text":"WorkingWithObjects/Parameterized.scala\ndef echo[T](input1: T, input2: T): Unit =\n  println(s\"got $input1 (${input1.getClass}) $input2 (${input2.getClass})\")\nWorkingWithObjects/Parameterized.scala\necho(\"hello\", \"there\")\necho(4, 5)\n运行结果\ngot hello (class java.lang.String) there (class java.lang.String)\ngot 4 (class java.lang.Integer) 5 (class java.lang.Integer)\nWorkingWithObjects/Parameterized.scala\necho(\"hi\", 5)\n运行结果\ngot hi (class java.lang.String) 5 (class java.lang.Integer)\nWorkingWithObjects/EchoErr.scala\necho[Int](\"hi\", 5) //error: type mismatch\nWorkingWithObjects/Parameterized.scala\ndef echo2[T1, T2](input1: T1, input2: T2): Unit =\n  println(s\"received $input1 and $input2\")\n\necho2(\"Hi\", \"5\")\nWorkingWithObjects/Parameterized.scala\nclass Message[T](val content: T) {\n  override def toString = s\"message content is $content\"\n\n  def is(value: T): Boolean = value == content\n}\nWorkingWithObjects/Parameterized.scala\nval message1: Message[String] = new Message(\"howdy\")\nval message2 = new Message(42)\n\nprintln(message1)\nprintln(message1.is(\"howdy\"))\nprintln(message1.is(\"hi\"))\nprintln(message2.is(22))\n运行结果\nmessage content is howdy\ntrue\nfalse\nfalse\nWorkingWithObjects/Message.scala\nmessage1.is(22) //error: type mismatch\nWorkingWithObjects/Message.scala\nmessage2.is('A') //No error!","title":"4.5 参数化类型"},{"location":"/chapter-04/index.html#4-6-单例对象和伴生对象","text":"WorkingWithObjects/Singleton.scala\nimport scala.collection._\n\nclass Marker(val color: String) {\n  println(s\"Creating ${this}\")\n\n  override def toString = s\"marker color $color\"\n}\n\nobject MarkerFactory {\n  private val markers =\n    mutable.Map(\"red\" -> new Marker(\"red\"), \"blue\" -> new Marker(\"blue\"), \"yellow\" -> new Marker(\"yellow\"))\n\n  def getMarker(color: String): Marker =\n    markers.getOrElseUpdate(color, new Marker(color))\n}\n\nprintln(MarkerFactory.getMarker(\"blue\"))\nprintln(MarkerFactory.getMarker(\"blue\"))\nprintln(MarkerFactory.getMarker(\"red\"))\nprintln(MarkerFactory.getMarker(\"red\"))\nprintln(MarkerFactory.getMarker(\"green\"))\n运行结果\nCreating marker color red\nCreating marker color blue\nCreating marker color yellow\nmarker color blue\nmarker color blue\nmarker color red\nmarker color red\nCreating marker color green\nmarker color green\nWorkingWithObjects/Marker.scala\nimport scala.collection._\n\nclass Marker private (val color: String) {\n  println(s\"Creating ${this}\")\n\n  override def toString = s\"marker color $color\"\n}\n\nobject Marker {\n  private val markers =\n    mutable.Map(\"red\" -> new Marker(\"red\"), \"blue\" -> new Marker(\"blue\"), \"yellow\" -> new Marker(\"yellow\"))\n\n  def getMarker(color: String): Marker =\n    markers.getOrElseUpdate(color, new Marker(color))\n}\n\nprintln(Marker.getMarker(\"blue\"))\nprintln(Marker.getMarker(\"blue\"))\nprintln(Marker.getMarker(\"red\"))\nprintln(Marker.getMarker(\"red\"))\nprintln(Marker.getMarker(\"green\"))\n运行结果\nCreating marker color red\nCreating marker color blue\nCreating marker color yellow\nmarker color blue\nmarker color blue\nmarker color red\nmarker color red\nCreating marker color green\nmarker color green\nWorkingWithObjects/Static.scala\nimport scala.collection._\n\nclass Marker private (val color: String) {\n  override def toString = s\"marker color $color\"\n}\nobject Marker {\n  private val markers =\n    mutable.Map(\"red\" -> new Marker(\"red\"), \"blue\" -> new Marker(\"blue\"), \"yellow\" -> new Marker(\"yellow\"))\n\n  def supportedColors: Iterable[String] = markers.keys\n  def apply(color: String): Marker = markers.getOrElseUpdate(color, op = new Marker(color))\n}\nprintln(s\"Supported colors are : ${Marker.supportedColors}\")\nprintln(Marker(\"blue\"))\nprintln(Marker(\"red\"))\n运行结果\nCreating marker color red\nCreating marker color blue\nCreating marker color yellow\nmarker color blue\nmarker color blue\nmarker color red\nmarker color red\nCreating marker color green\nmarker color green\nWorkingWithObjects/Greeter.scala\nobject Greeter {\n  def greet(): Unit = println(\"Ahoy, me hearties!\")\n}\n运行结果\nCompiled from \"Greeter.scala\"\npublic final class Greeter {\n  public static void greet();\n}","title":"4.6 单例对象和伴生对象"},{"location":"/chapter-04/index.html#4-7-创建枚举类","text":"WorkingWithObjects/Currency.scala\npackage chapter4.finance1.finance.currencies\n\nobject Currency extends Enumeration {\n  type Currency = Value\n  val CNY, GBP, INR, JPY, NOK, PLN, SEK, USD = Value\n}\nWorkingWithObjects/finance1/finance/currencies/Money.scala\npackage chapter4.finance1.finance.currencies\n\nimport Currency._\n\nclass Money(val amount: Int, val currency: Currency) {\n  override def toString = s\"$amount $currency\"\n}\nWorkingWithObjects/UseCurrency.scala\nimport chapter4.finance1.finance.currencies.Currency\n\nobject UseCurrency extends App {\n  Currency.values.foreach { currency =>\n    println(currency)\n  }\n}\n运行结果\nCNY\nGBP\nINR\nJPY\nNOK\nPLN\nSEK\nUSD","title":"4.7 创建枚举类"},{"location":"/chapter-04/index.html#4-8-包对象","text":"WorkingWithObjects/finance1/finance/currencies/Converter.scala\npackage chapter4.finance1.finance.currencies\n\nimport Currency._\n\nobject Converter {\n  def convert(money: Money, to: Currency): Money = {\n    //fetch current market rate... using mocked value here\n    val conversionRate = 2\n    new Money(money.amount * conversionRate, to)\n  }\n}\nWorkingWithObjects/finance1/finance/currencies/Charge.scala\npackage chapter4.finance1.finance.currencies\n\nobject Charge {\n  def chargeInUSD(money: Money): String = {\n    def moneyInUSD = Converter.convert(money, Currency.USD)\n    s\"charged $$${moneyInUSD.amount}\"\n  }\n}\nWorkingWithObjects/finance1/CurrencyApp.scala\nimport chapter4.finance1.finance.currencies._\n\nobject CurrencyApp extends App {\n  var moneyInGBP = new Money(10, Currency.GBP)\n\n  println(Charge.chargeInUSD(moneyInGBP))\n\n  println(Converter.convert(moneyInGBP, Currency.USD))\n}\nWorkingWithObjects/finance2/finance/currencies/package.scala\npackage chapter4.finance2.finance\n\npackage object currencies {\n  import Currency._\n\n  def convert(money: Money, to: Currency): Money = {\n    //fetch current market rate... using mocked value here\n    val conversionRate = 2\n    new Money(money.amount * conversionRate, to)\n  }\n}\nWorkingWithObjects/finance2/finance/currencies/Charge.scala\npackage chapter4.finance2.finance.currencies\n\nobject Charge {\n  def chargeInUSD(money: Money): String = {\n    def moneyInUSD = convert(money, Currency.USD)\n    s\"charged $$${moneyInUSD.amount}\"\n  }\n}\nWorkingWithObjects/finance2/CurrencyApp.scala\npackage chapter4.finance2\n\nimport chapter4.finance2.finance.currencies._\n\nobject CurrencyApp extends App {\n  var moneyInGBP = new Money(10, Currency.GBP)\n\n  println(Charge.chargeInUSD(moneyInGBP))\n\n  println(convert(moneyInGBP, Currency.USD))\n}\n运行结果\nCNY\nGBP\nINR\nJPY\nNOK\nPLN\nSEK\nUSD","title":"4.8 包对象"},{"location":"/chapter-05/index.html","text":"","title":"第5章——善用类型 ·"},{"location":"/chapter-05/index.html#第5章-善用类型","text":"Scala 的关键优点之一便是 Scala 是静态类型的。通过静态类型，编译器充当了抵御错误 的第一道防线。它们可以验证当前的对象是否就是想要的类型。这是一种在编译时强制接口 约定的方式。这样的验证可以使我们相信，编译后的代码满足我们的预期。","title":"第5章——善用类型"},{"location":"/chapter-05/index.html#5-1-类型推断","text":"MakingUseOfTypes/DefiningVariableWithType.scala\nval greet: String = \"Ahoy!\"\nMakingUseOfTypes/DefiningVariable.scala\nval greet = \"Ahoy!\"\nMakingUseOfTypes/DefiningVariable.scala\nprintln(greet)\nprintln(greet.getClass)\n运行结果\nAhoy!\nclass java.lang.String\nMakingUseOfTypes/TypeInference.scala\nclass TypeInference {\n  val greet = \"Ahoy!\"\n}\n使用命令\nscalac -d bin TypeInference.scala\njavap -classpath bin -private TypeInference\n反编译结果\nCompiled from \"TypeInference.scala\"\npublic class TypeInference {\n  private final java.lang.String greet;\n  public java.lang.String greet();\n  public TypeInference();\n}\nREPL运行结果\nscala> val greet = \"Ahoy!\"\ngreet: String = Ahoy!\n\nscala> :quit\nMakingUseOfTypes/Generics.scala\nimport java._\n\nvar list1: util.List[Int] = new util.ArrayList[Int]\nvar list2 = new util.ArrayList[Int]\nMakingUseOfTypes/Generics2.scala\nimport java._\n\nvar list1 = new util.ArrayList[Int]\nvar list2 = new util.ArrayList\nlist2.add(???)\n\nlist2 = list1 // Compilation Error\n运行结果\nGenerics2.scala:5: error: type mismatch;\n found   : java.util.ArrayList[Int]\n required: java.util.ArrayList[Nothing]\nNote: Int >: Nothing, but Java-defined class ArrayList is invariant in \ntype E.\nYou may wish to investigate a wildcard type such as `_ >: Nothing`. (SLS \n3.2.10)\nlist2 = list1 // Compilation Error\n        ^\none error found\nMakingUseOfTypes/Generics3.scala\nimport java._\n\nvar list1 = new util.ArrayList[Int]\nvar list2 = new util.ArrayList[Any]\n\nvar ref1: Int = 1\nvar ref2: Any = _\n\nref2 = ref1 //OK\n\nlist2 = list1 // Compilation Error\n运行结果\nGenerics3.scala:11: error: type mismatch;\n found   : java.util.ArrayList[Int]\n required: java.util.ArrayList[Any]\nNote: Int <: Any, but Java-defined class ArrayList is invariant in type E.\nYou may wish to investigate a wildcard type such as `_ <: Any`. (SLS \n3.2.10)\nlist2 = list1 // Compilation Error\n        ^\none error found","title":"5.1 类型推断"},{"location":"/chapter-05/index.html#5-2-基础类型","text":"MakingUseOfTypes/ExceptionThrowing.scala\ndef someOp(number: Int) =\n  if (number < 10)\n    number * 2\n  else\n    throw new RuntimeException(\"invalid argument\")\n运行结果\nscala> def madMethod() = { throw new IllegalArgumentException() }\nmadMethod: ()Nothing\n\nscala> :quit\nMakingUseOfTypes/OptionExample.scala\ndef commentOnPractice(input: String) = {\n  //rather than returning null\n  if (input == \"test\") Some(\"good\") else None\n}\n\nfor (input <- Set(\"test\", \"hack\")) {\n  val comment = commentOnPractice(input)\n  val commentDisplay = comment.getOrElse(\"Found no comments\")\n  println(s\"input: $input comment: $commentDisplay\")\n}\n运行结果\ninput: test comment: good\ninput: hack comment: Found no comments\nMakingUseOfTypes/UsingEither.scala\ndef compute(input: Int) =\n  if (input > 0)\n    Right(math.sqrt(input))\n  else\n    Left(\"Error computing, invalid input\")\nMakingUseOfTypes/UsingEither.scala\ndef displayResult(result: Either[String, Double]): Unit = {\n  println(s\"Raw: $result\")\n  result match {\n    case Right(value) => println(s\"result $value\")\n    case Left(err) => println(s\"Error: $err\")\n  }\n}\nMakingUseOfTypes/UsingEither.scala\ndisplayResult(compute(4))\ndisplayResult(compute(-4))\n运行结果\nRaw: Right(2.0)\nresult 2.0\nRaw: Left(Error computing, invalid input)\nError: Error computing, invalid input","title":"5.2 基础类型"},{"location":"/chapter-05/index.html#5-3-返回值类型推断","text":"MakingUseOfTypes/Functions.scala\ndef function1(): Unit = { Math.sqrt(4) }\ndef function2 = { Math.sqrt(4) }\ndef function3 = Math.sqrt(4)\ndef function4: Double = { Math.sqrt(4) }\n运行结果\nscala> def function1 { Math.sqrt(4) }\nfunction1: Unit\n\nscala> def function2 = { Math.sqrt(4) }\nfunction2: Double\n\nscala> def function3 = Math.sqrt(4)\nfunction3: Double\n\nscala> def function4 : Double = { Math.sqrt(4) }\nfunction4: Double\n\nscala> :quit\nMakingUseOfTypes/NotAllowed.scala\nvar arr1 = new Array[Int](3)\nvar arr2: Array[Any] = _\n\narr2 = arr1 // Compilation ERROR\n运行结果\nNotAllowed.scala:4: error: type mismatch;\n found   : Array[Int]\n required: Array[Any]\nNote: Int <: Any, but class Array is invariant in type T.\nYou may wish to investigate a wildcard type such as `_ <: Any`. (SLS \n3.2.10)\narr2 = arr1 // Compilation ERROR\n       ^\none error found","title":"5.3 返回值类型推断"},{"location":"/chapter-05/index.html#5-4-参数化类型的型变","text":"MakingUseOfTypes/Trouble.java\n//Java code \nclass Fruit {} \nclass Banana extends Fruit {}\nclass Apple extends Fruit {}\n\npublic class Trouble {\n  public static void main(String[] args) {\n    Banana[] basketOfBanana = new Banana[2];\n    basketOfBanana[0] = new Banana();\n    \n    Fruit[] basketOfFruits = basketOfBanana; \n    basketOfFruits[1] = new Apple(); \n    \n    for(Banana banana : basketOfBanana) {\n      System.out.println(banana);\n    }    \n  }\n}\n运行结果\nException in thread \"main\" java.lang.ArrayStoreException: Apple\n\tat Trouble.main(Trouble.java:12)\nMakingUseOfTypes/OKJava.java\n// Java code\nArrayList<Integer> list = new ArrayList<Integer>();\nArrayList<Object> list2 = list; // Compilation error\n绕开限制\nArrayList list3 = list;\n运行结果\nOKJava.java:8: error: incompatible types: ArrayList<Integer> cannot be\nconverted to ArrayList<Object>\n    ArrayList<Object> list2 = list; // Compilation error\n                              ^\n1 error\nclass Pet(val name: String) {\n  override def toString: String = name\n}\n\nclass Dog(override val name: String) extends Pet(name)\n\ndef workWithPets(pets: Array[Pet]): Unit = {}\nMakingUseOfTypes/PlayWithPets.scala\nval dogs = Array(new Dog(\"Rover\"), new Dog(\"Comet\"))\nMakingUseOfTypes/PlayWithPets.scala\ndef playWithPets[T <: Pet](pets: Array[T]): Unit =\n  println(\"Playing with pets: \" + pets.mkString(\", \"))\nMakingUseOfTypes/PlayWithPets.scala\nplayWithPets(dogs)\n运行结果\nPlaying with pets: Rover, Comet\nMakingUseOfTypes/PlayWithPets.scala\ndef copyPets[S, D >: S](fromPets: Array[S], toPets: Array[D]): Unit = { //...\n}\n\nval pets = new Array[Pet](10)\ncopyPets(dogs, pets)\nMakingUseOfTypes/MyList.scala\nclass MyList[+T] //...\nvar list1 = new MyList[Int]\nvar list2: MyList[Any] = _\nlist2 = list1 // OK","title":"5.4 参数化类型的型变"},{"location":"/chapter-05/index.html#5-5-隐式类型转换","text":"MakingUseOfTypes/DateHelper1.scala\nimport scala.language.implicitConversions\nimport java.time.LocalDate\n\nclass DateHelper(offset: Int) {\n  def days(when: String): LocalDate = {\n    val today = LocalDate.now\n    when match {\n      case \"ago\" => today.minusDays(offset)\n      case \"from_now\" => today.plusDays(offset)\n      case _ => today\n    }\n  }\n}\nMakingUseOfTypes/DateHelper1.scala\nimplicit def convertInt2DateHelper(offset: Int): DateHelper = new DateHelper(offset)\n\nval ago = \"ago\"\nval from_now = \"from_now\"\n\nval past = 2.days(ago)\nval appointment = 5.days(from_now)\n\nprintln(past)\nprintln(appointment)\n运行结果\n2015-08-11\n2015-08-18\nMakingUseOfTypes/DateHelper.scala\nimport scala.language.implicitConversions\nimport java.time.LocalDate\n\nclass DateHelper(offset: Int) {\n  def days(when: String): LocalDate = {\n    val today = LocalDate.now\n    when match {\n      case \"ago\" => today.minusDays(offset)\n      case \"from_now\" => today.plusDays(offset)\n      case _ => today\n    }\n  }\n}\n\nobject DateHelper {\n  val ago = \"ago\"\n  val from_now = \"from_now\"\n  implicit def convertInt2DateHelper(offset: Int): DateHelper = new DateHelper(offset)\n}\nMakingUseOfTypes/DaysDSL.scala\nimport DateHelper._\n\nobject DaysDSL extends App {\n  val past = 2.days(ago)\n  val appointment = 5.days(from_now)\n\n  println(past)\n  println(appointment)\n}\n运行结果\n2015-08-11\n2015-08-18\nMakingUseOfTypes/DateUtil.scala\nobject DateUtil {\n  val ago = \"ago\"\n  val from_now = \"from_now\"\n\n  implicit class DateHelper(val offset: Int) {\n    import java.time.LocalDate\n    def days(when: String): LocalDate = {\n      val today = LocalDate.now\n      when match {\n        case \"ago\" => today.minusDays(offset)\n        case \"from_now\" => today.plusDays(offset)\n        case _ => today\n      }\n    }\n  }\n}\nMakingUseOfTypes/DateUtil.scala\nobject UseDateUtil extends App {\n  import DateUtil._\n\n  val past = 2.days(ago)\n  val appointment = 5.days(from_now)\n\n  println(past)\n  println(appointment)\n}\n运行结果\n5: invokevirtual #73                 // Method\nDateUtil$.DateHelper:(I)LDateUtil$DateHelper;\n       8: getstatic     #69                 // Field \nDateUtil$.MODULE$:LDateUtil$;\n      11: invokevirtual #77                 // Method \nDateUtil$.ago:()Ljava/lang/String;\n      14: invokevirtual #83                 // Method \nDateUtil$DateHelper.days:(Ljava/lang/String;)Ljava/time/LocalDate;","title":"5.5 隐式类型转换"},{"location":"/chapter-05/index.html#5-6-值类","text":"MakingUseOfTypes/ValDateUtil.scala\nimplicit class DateHelper(val offset: Int) extends AnyVal {\n反编译结果\n8: invokevirtual #78                 // Method\nDateUtil$.DateHelper:(I)I\n      11: getstatic     #74                 // Field \nDateUtil$.MODULE$:LDateUtil$;\n      14: invokevirtual #82                 // Method \nDateUtil$.ago:()Ljava/lang/String;\n      17: invokevirtual #86                 // Method \nDateUtil$DateHelper$.days$extension:(ILjava/lang/String;)Ljava/time/LocalDate;\nMakingUseOfTypes/NameExample.scala\nclass Name(val value: String) {\n  override def toString: String = value\n  def length: Int = value.length\n}\n\nobject UseName extends App {\n  def printName(name: Name): Unit = {\n    println(name)\n  }\n\n  val name = new Name(\"Snowy\")\n  println(name.length)\n  printName(name)\n}\n反编译结果\n5: ldc           #76                 // String Snowy\n       7: invokespecial #79                 // Method \nName.\"<init>\":(Ljava/lang/String;)V\n      10: putfield      #71                 // Field name:LName;\n      13: getstatic     #64                 // Field \nscala/Predef$.MODULE$:Lscala/Predef$;\n      16: aload_0\n      17: invokevirtual #81                 // Method name:()LName;\n      20: invokevirtual #85                 // Method Name.length:()I\n      23: invokestatic  #91                 // Method \nscala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;\n      26: invokevirtual #68                 // Method \nscala/Predef$.println:(Ljava/lang/Object;)V\n      29: aload_0\n      30: aload_0\n      31: invokevirtual #81                 // Method name:()LName;\n      34: invokevirtual #93                 // Method printName:(LName;)V\n      37: return\nMakingUseOfTypes/NameValExample.scala\nclass Name(val value: String) extends AnyVal {\n反编译结果\n1: ldc           #78                 // String Snowy\n       3: putfield      #75                 // Field \nname:Ljava/lang/String;\n       6: getstatic     #64                 // Field \nscala/Predef$.MODULE$:Lscala/Predef$;\n       9: getstatic     #83                 // Field Name$.MODULE$:LName$;\n      12: aload_0\n      13: invokevirtual #85                 // Method \nname:()Ljava/lang/String;\n      16: invokevirtual #89                 // Method \nName$.length$extension:(Ljava/lang/String;)I\n      19: invokestatic  #95                 // Method \nscala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;\n      22: invokevirtual #72                 // Method \nscala/Predef$.println:(Ljava/lang/Object;)V\n      25: aload_0\n      26: aload_0\n      27: invokevirtual #85                 // Method \nname:()Ljava/lang/String;\n      30: invokevirtual #97                 // Method \nprintName:(Ljava/lang/String;)V\n      33: return\nMakingUseOfTypes/NameVal2Example.scala\nval any: Any = name","title":"5.6 值类"},{"location":"/chapter-05/index.html#5-7-使用隐式转换","text":"MakingUseOfTypes/Mask.scala\nimport MyInterpolator._\n\nval ssn = \"123-45-6789\"\nval account = \"0246781263\"\nval balance = 20145.23\n\nprintln(mask\"\"\"Account: $account\n  |Social Security Number: $ssn\n  |Balance: $$^$balance\n  |Thanks for your business.\"\"\".stripMargin)\nMakingUseOfTypes/MyInterpolator.scala\nobject MyInterpolator {\n  implicit class Interpolator(val context: StringContext) extends AnyVal {\n    def mask(args: Any*): String = {\n      val processed = context.parts\n        .zip(args)\n        .map { item =>\n          val (text, expression) = item\n          if (text.endsWith(\"^\"))\n            s\"${text.split('^')(0)}$expression\"\n          else\n            s\"$text...${expression.toString.takeRight(4)}\"\n        }\n        .mkString\n\n      new StringBuilder(processed).append(context.parts.last).toString()\n    }\n  }\n}\n使用命令\nscalac MyInterpolator.scala mask.scala\nscala UseInterpolator\n运行结果\nAccount: ...1263\nSocial Security Number: ...6789\nBalance: $20145.23\nThanks for your business.","title":"5.7 使用隐式转换"},{"location":"/part2.html","text":"","title":"第二部分 深入 Scala ·"},{"location":"/part2.html#第二部分-深入-scala","text":"是时候深入学习 Scala 了。读者将了解：\n如何创建和使用函数值； 如何使用特质进行编程； 如何使用不同类型的集合； 如何使用模式匹配的能力； 如何进行尾调用优化。","title":"第二部分 深入 Scala"},{"location":"/chapter-06/index.html","text":"","title":"第6章——函数值和闭包 ·"},{"location":"/chapter-06/index.html#第6章-函数值和闭包","text":"在函数式编程中，函数是一等公民。函数可以作为参数值传入其他函数中，函数的返回值可 以是函数，函数甚至可以嵌套函数。这些高阶函数在 Scala 中被称为函数值（function value）。闭 包（closure）是函数值的特殊形式，会捕获或者绑定到在另一个作用域或上下文中定义的变量。","title":"第6章——函数值和闭包"},{"location":"/chapter-06/index.html#6-1-常规函数的局限性","text":"FunctionValuesAndClosures/Sum.scala\ndef sum(number: Int) = {\n  var result = 0\n  for (i <- 1 to number) {\n    result += i\n  }\n  result\n}","title":"6.1 常规函数的局限性"},{"location":"/chapter-06/index.html#6-2-可扩展性与高阶函数","text":"FunctionValuesAndClosures/Loop.scala\ndef totalResultOverRange(number: Int, codeBlock: Int => Int) = {\n  var result = 0\n  for (i <- 1 to number) {\n    result += codeBlock(i)\n  }\n  result\n}\nFunctionValuesAndClosures/Loop.scala\nprintln(totalResultOverRange(11, i => i))\nFunctionValuesAndClosures/Loop.scala\nprintln(totalResultOverRange(11, i => if (i % 2 == 0) i else 0))\nFunctionValuesAndClosures/Loop.scala\nprintln(totalResultOverRange(11, i => if (i % 2 != 0) i else 0))","title":"6.2 可扩展性与高阶函数"},{"location":"/chapter-06/index.html#6-3-具有多个参数的函数值","text":"FunctionValuesAndClosures/ZeroParam.scala\ndef printValue(generator: () => Int): Unit = {\n  println(s\"Generated value is ${generator()}\")\n}\n\nprintValue(() => 42)\nFunctionValuesAndClosures/Inject.scala\ndef inject(arr: Array[Int], initial: Int, operation: (Int, Int) => Int) = {\n  var carryOver = initial\n  arr.foreach(element => carryOver = operation(carryOver, element))\n  carryOver\n}\nFunctionValuesAndClosures/Inject.scala\nval array = Array(2, 3, 5, 1, 6, 4)\nval sum = inject(array, 0, (carry, elem) => carry + elem)\nprintln(s\"Sum of elements in array is $sum\")\nFunctionValuesAndClosures/Inject.scala\nval max =\n  inject(array, Integer.MIN_VALUE, (carry, elem) => Math.max(carry, elem))\nprintln(s\"Max of elements in array is  $max\")\n运行结果\nSum of elements in array is 21\nMax of elements in array is  6\nFunctionValuesAndClosures/Inject2.scala\nval sum = array.foldLeft(0)((sum, elem) => sum + elem) //可以被替换为对sum方法的调用\nval max = array.foldLeft(Integer.MIN_VALUE) { (large, elem) =>\n  Math.max(large, elem)\n}\n\nprintln(s\"Sum of elements in array is $sum\")\nprintln(s\"Max of elements in array is $max\")\nFunctionValuesAndClosures/Inject2.scala\nval sum = (0 /: array) { (sum, elem) =>\n  sum + elem\n}\nval max =\n  (Integer.MIN_VALUE /: array) { (large, elem) =>\n    Math.max(large, elem)\n  }\nFunctionValuesAndClosures/Inject3.scala\nval sum = inject(array, 0) { (carryOver, elem) =>\n  carryOver + elem\n}\n运行结果\nInject3.scala:9: error: not enough arguments for method inject: (arr:\nArray[Int], initial: Int, operation: (Int, Int) => Int)Int.\nUnspecified value parameter operation.\nval sum = inject(array, 0) {(carryOver, elem) => carryOver + elem}\n                ^\none error found","title":"6.3 具有多个参数的函数值"},{"location":"/chapter-06/index.html#6-4-柯里化","text":"scala> def foo(a: Int)(b: Int)(c:Int) = {}\nfoo: (a: Int)(b: Int)(c: Int)Unit\n\nscala> foo _\nres0: Int => (Int => (Int => Unit)) = <function1>\n\nscala> :quit\nFunctionValuesAndClosures/Inject4.scala\ndef inject(arr: Array[Int], initial: Int)(operation: (Int, Int) => Int): Int = {\n  var carryOver = initial\n  arr.foreach(element => carryOver = operation(carryOver, element))\n  carryOver\n}\nFunctionValuesAndClosures/Inject4.scala\nval sum: Int = inject(array, 0) { (carryOver, elem) =>\n  carryOver + elem\n}","title":"6.4 柯里化"},{"location":"/chapter-06/index.html#6-5-参数的占位符","text":"FunctionValuesAndClosures/Underscore.scala\nval arr = Array(1, 2, 3, 4, 5)\n\nval total = arr.foldLeft(0) { (sum, elem) =>\n  sum + elem\n}\nFunctionValuesAndClosures/Underscore.scala\nval total = arr.foldLeft(0) { _ + _ }\nFunctionValuesAndClosures/Underscore.scala\nval negativeNumberExists1 = arr.exists { elem =>\n  elem < 0\n}\nval negativeNumberExists2 = arr.exists { _ < 0 }","title":"6.5 参数的占位符"},{"location":"/chapter-06/index.html#6-6-参数路由","text":"FunctionValuesAndClosures/RouteParams.scala\nval largest =\n  (Integer.MIN_VALUE /: arr) { (carry, elem) =>\n    Math.max(carry, elem)\n  }\nFunctionValuesAndClosures/RouteParams.scala\nval largest = (Integer.MIN_VALUE /: arr) { Math.max(_, _) }\nFunctionValuesAndClosures/RouteParams.scala\nval largest = (Integer.MIN_VALUE /: arr) { Math.max _ }\nFunctionValuesAndClosures/RouteParams.scala\nval largest = (Integer.MIN_VALUE /: arr) { Math.max }","title":"6.6 参数路由"},{"location":"/chapter-06/index.html#6-7-复用函数值","text":"FunctionValuesAndClosures/Equipment.scala\nclass Equipment(val routine: Int => Int) {\n  def simulate(input: Int): Int = {\n    print(\"Running simulation...\")\n    routine(input)\n  }\n}\nFunctionValuesAndClosures/EquipmentUseNotDry.scala\nobject EquipmentUseNotDry extends App {\n  val equipment1 = new Equipment({ input =>\n    println(s\"calc with $input\"); input\n  })\n  val equipment2 = new Equipment({ input =>\n    println(s\"calc with $input\"); input\n  })\n\n  equipment1.simulate(4)\n  equipment2.simulate(6)\n}\n运行结果\nRunning simulation...calc with 4\nRunning simulation...calc with 6\nFunctionValuesAndClosures/EquipmentUseNotDry.scala\nobject EquipmentUseDry extends App {\n  val calculator = { input: Int =>\n    println(s\"calc with $input\"); input\n  }\n\n  val equipment1 = new Equipment(calculator)\n  val equipment2 = new Equipment(calculator)\n\n  equipment1.simulate(4)\n  equipment2.simulate(6)\n}\n运行结果\nRunning simulation...calc with 4\nRunning simulation...calc with 6\nFunctionValuesAndClosures/EquipmentUseNotDry2.scala\nobject EquipmentUseDry2 extends App {\n  def calculator(input: Int) = { println(s\"calc with $input\"); input }\n\n  val equipment1 = new Equipment(calculator)\n  val equipment2 = new Equipment(calculator)\n\n  equipment1.simulate(4)\n  equipment2.simulate(6)\n}\n运行结果\nRunning simulation...calc with 4\nRunning simulation...calc with 6","title":"6.7 复用函数值"},{"location":"/chapter-06/index.html#6-8-部分应用函数","text":"FunctionValuesAndClosures/Log.scala\nimport java.util.Date\n\ndef log(date: Date, message: String): Unit = {\n  //...\n  println(s\"$date ---- $message\")\n}\n\nval date = new Date(1420095600000L)\nlog(date, \"message1\")\nlog(date, \"message2\")\nlog(date, \"message3\")\nFunctionValuesAndClosures/Log.scala\nval date = new Date(1420095600000L)\nval logWithDateBound = log(date, _: String)\nlogWithDateBound(\"message1\")\nlogWithDateBound(\"message2\")\nlogWithDateBound(\"message3\")\n运行结果\nscala> import java.util.Date\nimport java.util.Date\n\nscala> def log(date: Date, message: String) =  println(s\"$date ---- \n$message\")\nlog: (date: java.util.Date, message: String)Unit\n\nscala> val logWithDateBound = log(new Date, _ : String)\nlogWithDateBound: String => Unit = <function1>\n\nscala> :quit","title":"6.8 部分应用函数"},{"location":"/chapter-06/index.html#6-9-闭包","text":"FunctionValuesAndClosures/Closure.scala\ndef loopThrough(number: Int)(closure: Int => Unit): Unit = {\n  for (i <- 1 to number) { closure(i) }\n}\nFunctionValuesAndClosures/Closure.scala\nvar result = 0\nval addIt = { value: Int =>\n  result += value\n}\nFunctionValuesAndClosures/Closure.scala\nloopThrough(10) { elem =>\n  addIt(elem)\n}\nprintln(s\"Total of values from 1 to 10 is $result\")\n\nresult = 0\nloopThrough(5) { addIt }\nprintln(s\"Total of values from 1 to 5 is $result\")\nFunctionValuesAndClosures/Closure.scala\nvar product = 1\nloopThrough(5) { product *= _ }\nprintln(s\"Product of values from 1 to 5 is $product\")\n运行结果\nTotal of values from 1 to 10 is 55\nTotal of values from 1 to 5 is 15\nProduct of values from 1 to 5 is 120","title":"6.9 闭包"},{"location":"/chapter-06/index.html#6-10-execute-around-method-模式","text":"FunctionValuesAndClosures/Resource.scala\nclass Resource private () {\n  println(\"Starting transaction...\")\n  private def cleanUp(): Unit = { println(\"Ending transaction...\") }\n  def op1(): Unit = println(\"Operation 1\")\n  def op2(): Unit = println(\"Operation 2\")\n  def op3(): Unit = println(\"Operation 3\")\n}\n\nobject Resource {\n  def use(codeBlock: Resource => Unit): Unit = {\n    val resource = new Resource\n    try {\n      codeBlock(resource)\n    } finally {\n      resource.cleanUp()\n    }\n  }\n}\nFunctionValuesAndClosures/Resource.scala\nResource.use { resource =>\n  resource.op1()\n  resource.op2()\n  resource.op3()\n  resource.op1()\n}\n运行结果\nStarting transaction...\nOperation 1\nOperation 2\nOperation 3\nOperation 1\nEnding transaction...\nFunctionValuesAndClosures/WriteToFile.scala\nimport java.io._\n\ndef writeToFile(fileName: String)(codeBlock: PrintWriter => Unit): Unit = {\n  val writer = new PrintWriter(new File(fileName))\n  try {\n    codeBlock(writer)\n  } finally {\n    writer.close()\n  }\n}\nFunctionValuesAndClosures/WriteToFile.scala\nwriteToFile(\"output/output.txt\") { writer =>\n  writer.write(\"hello from Scala\")\n}\n运行结果\nhello from Scala","title":"6.10 Execute Around Method 模式"},{"location":"/chapter-07/index.html","text":"","title":"第7章——特质 ·"},{"location":"/chapter-07/index.html#第7章-特质","text":"Java 只允许单继承，这会强制建立一种线性的层次结构模型。但现实世界中充满了横切 关注点（crosscutting concerns）—一种横切且影响多个抽象的概念，这些抽象并不同属于 某个单一的类层次结构 ① 。在典型的企业级应用程序中，安全、日志记录、验证、事务以及 资源管理都是这些横切关注点的应用场景。但是，因为我们受限于单一的类层次结构，所以 实现这些横切关注点变得相当困难，往往需要代码上的重复或者引入重量级工具 ② 。Scala 使 用特质（trait）解决了这个问题。\n即横跨应用程序中多个模块的特性。——译者注","title":"第7章——特质"},{"location":"/chapter-07/index.html#7-1-理解特质","text":"UsingTraits/HumanWithListen.scala\nclass Human(val name: String) {\n  def listen(): Unit = println(s\"Your friend $name is listening\")\n}\n\nclass Man(override val name: String) extends Human(name)\nclass Woman(override val name: String) extends Human(name)\nUsingTraits/Friend.scala\ntrait Friend {\n  val name: String\n  def listen(): Unit = println(s\"Your friend $name is listening\")\n}\nUsingTraits/Human.scala\nclass Human(val name: String) extends Friend\n\nclass Woman(override val name: String) extends Human(name)\nclass Man(override val name: String) extends Human(name)\nUsingTraits/Dog.scala\nclass Dog(val name: String) extends Animal with Friend {\n  //optionally override method here.\n  override def listen(): Unit = println(s\"$name's listening quietly\")\n}\nUsingTraits/Animal.scala\nclass Animal\nUsingTraits/UseFriend.scala\nobject UseFriend extends App {\n  val john = new Man(\"John\")\n  val sara = new Woman(\"Sara\")\n  val comet = new Dog(\"Comet\")\n\n  john.listen()\n  sara.listen()\n  comet.listen()\n\n  val mansBestFriend: Friend = comet\n  mansBestFriend.listen()\n\n  def helpAsFriend(friend: Friend): Unit = friend.listen()\n\n  helpAsFriend(sara)\n  helpAsFriend(comet)\n}\n运行结果\nYour friend John is listening\nYour friend Sara is listening\nComet's listening quietly\nComet's listening quietly\nYour friend Sara is listening\nComet's listening quietly","title":"7.1 理解特质"},{"location":"/chapter-07/index.html#7-2-选择性混入","text":"UsingTraits/Cat.scala\nclass Cat(val name: String) extends Animal\nUsingTraits/UseCat.scala\nobject UseCat extends App {\n  def useFriend(friend: Friend): Unit = friend.listen()\n\n  val alf = new Cat(\"Alf\")\n  val friend: Friend = alf // ERROR\n\n  useFriend(alf) // ERROR\n}\n编译结果\nUseCat.scala:5: error: type mismatch;\n found   : Cat\n required: Friend\n  val friend : Friend = alf // ERROR\n                        ^\nUseCat.scala:7: error: type mismatch;\n found   : Cat\n required: Friend\n  useFriend(alf) // ERROR\n            ^\ntwo errors found\nUsingTraits/TreatCatAsFriend.scala\ndef useFriend(friend: Friend): Unit = friend.listen()\n\nval angel = new Cat(\"Angel\") with Friend\nval friend: Friend = angel\nangel.listen()\n\nuseFriend(angel)\n运行结果\nYour friend Angel is listening\nYour friend Angel is listening","title":"7.2 选择性混入"},{"location":"/chapter-07/index.html#7-3-使用特质实现装饰器模式","text":"UsingTraits/Decorator.scala\nabstract class Check {\n  def check: String = \"Checked Application Details...\"\n}\nUsingTraits/Decorator.scala\ntrait CreditCheck extends Check {\n  override def check: String = s\"Checked Credit... ${super.check}\"\n}\n\ntrait EmploymentCheck extends Check {\n  override def check: String = s\"Checked Employment...${super.check}\"\n}\n\ntrait CriminalRecordCheck extends Check {\n  override def check: String = s\"Check Criminal Records...${super.check}\"\n}\nUsingTraits/Decorator.scala\nval apartmentApplication =\n  new Check with CreditCheck with CriminalRecordCheck\n\nprintln(apartmentApplication.check)\nUsingTraits/Decorator.scala\nval employmentApplication =\n  new Check with CriminalRecordCheck with EmploymentCheck\n\nprintln(employmentApplication.check)\n运行结果\nCheck Criminal Records...Checked Credit... Checked Application Details...\nChecked Employment...Check Criminal Records...Checked Application \nDetails...","title":"7.3 使用特质实现装饰器模式"},{"location":"/chapter-07/index.html#7-4-特质中的方法延迟绑定","text":"UsingTraits/MethodBinding.scala\nabstract class Writer {\n  def writeMessage(message: String): Unit\n}\nUsingTraits/MethodBinding.scala\ntrait UpperCaseWriter extends Writer {\n  abstract override def writeMessage(message: String): Unit =\n    super.writeMessage(message.toUpperCase)\n}\n\ntrait ProfanityFilteredWriter extends Writer {\n  abstract override def writeMessage(message: String): Unit =\n    super.writeMessage(message.replace(\"stupid\", \"s-----\"))\n}\nUsingTraits/MethodBinding.scala\nclass StringWriterDelegate extends Writer {\n  val writer = new java.io.StringWriter\n\n  def writeMessage(message: String): Unit = writer.write(message)\n  override def toString: String = writer.toString\n}\nUsingTraits/MethodBinding.scala\nval myWriterProfanityFirst =\n  new StringWriterDelegate with UpperCaseWriter with ProfanityFilteredWriter\n\nval myWriterProfanityLast =\n  new StringWriterDelegate with ProfanityFilteredWriter with UpperCaseWriter\n\nmyWriterProfanityFirst.writeMessage(\"There is no sin except stupidity\")\nmyWriterProfanityLast.writeMessage(\"There is no sin except stupidity\")\n\nprintln(myWriterProfanityFirst)\nprintln(myWriterProfanityLast)\n运行结果\nTHERE IS NO SIN EXCEPT S-----ITY\nTHERE IS NO SIN EXCEPT STUPIDITY","title":"7.4 特质中的方法延迟绑定"},{"location":"/chapter-08/index.html","text":"","title":"第8章——集合 ·"},{"location":"/chapter-08/index.html#第8章-集合","text":"Scala 标准库包含了一组丰富的集合类，以及用于组合、遍历和提取元素的强大操作。在 创建 Scala 应用程序时，会经常用到这些集合。如果想要在使用 Scala 时更加具有生产力，彻 底地学习这些集合是很有必要的。","title":"第8章——集合"},{"location":"/chapter-08/index.html#8-1-常见的-scala-集合","text":"UsingCollections/UsingSet.scala\nval colors1 = Set(\"Blue\", \"Green\", \"Red\")\nprintln(s\"colors1: $colors1\")\n\nval colors2 = colors1 + \"Black\"\nprintln(s\"colors2: $colors2\")\nprintln(s\"colors1: $colors1\")\n运行结果\ncolors1: Set(Blue, Green, Red)\ncolors2: Set(Blue, Green, Red, Black)\ncolors1: Set(Blue, Green, Red)\nscala>  val colors = Set(\"Blue\", \"Green\", \"Red\")\ncolors: scala.collection.immutable.Set[String] = Set(Blue, Green, Red)\n\nscala> colors.getClass\nres0: Class[_ <: scala.collection.immutable.Set[String]] = class \nscala.collection.immutable.Set$Set3\n\nscala> :quit","title":"8.1 常见的 Scala 集合"},{"location":"/chapter-08/index.html#8-2-使用-set","text":"UsingCollections/UsingSet.scala\nval feeds1 = Set(\"blog.toolshed.com\", \"pragdave.me\", \"blog.agiledeveloper.com\")\nval feeds2 = Set(\"blog.toolshed.com\", \"martinfowler.com/bliki\")\nUsingCollections/UsingSet.scala\nval blogFeeds = feeds1.filter(_ contains \"blog\")\nprintln(s\"blog feeds: ${blogFeeds.mkString(\", \")}\")\n运行结果\nblog feeds: blog.toolshed.com, blog.agiledeveloper.com\nUsingCollections/UsingSet.scala\nval mergedFeeds = feeds1 ++ feeds2\nprintln(s\"# of merged feeds: ${mergedFeeds.size}\")\n运行结果\n# of merged feeds: 4\nUsingCollections/UsingSet.scala\nval commonFeeds = feeds1 & feeds2\nprintln(s\"common feeds: ${commonFeeds.mkString(\", \")}\")\n运行结果\ncommon feeds: blog.toolshed.com\nUsingCollections/UsingSet.scala\nval urls = feeds1.map(\"http://\" + _)\nprintln(s\"One url: ${urls.head}\")\n运行结果\nOne url: http://blog.toolshed.com\nUsingCollections/UsingSet.scala\nprintln(\"Refresh Feeds:\")\nfeeds1.foreach { feed =>\n  println(s\"  Refreshing $feed...\")\n}\n运行结果\nRefresh Feeds:\n  Refreshing blog.toolshed.com...\n  Refreshing pragdave.me...\n  Refreshing blog.agiledeveloper.com...","title":"8.2 使用 Set"},{"location":"/chapter-08/index.html#8-3-关联映射","text":"UsingCollections/PlayingWithMap.scala\nval feeds =\n  Map(\"Andy Hunt\" -> \"blog.toolshed.com\", \"Dave Thomas\" -> \"pragdave.me\", \"NFJS\" -> \"nofluffjuststuff.com/blog\")\nUsingCollections/PlayingWithMap.scala\nval filterNameStartWithD = feeds.filterKeys(_.startsWith(\"D\"))\nprintln(s\"# of Filtered: ${filterNameStartWithD.size}\")\n运行结果\n# of Filtered: 1\nUsingCollections/PlayingWithMap.scala\nval filterNameStartWithDAndPragprogInFeed = feeds.filter { element =>\n  val (key, value) = element\n  (key.startsWith(\"D\")) && (value contains \"pragdave\")\n}\nprint(\"# of feeds with auth name D* and pragdave in URL: \")\nprintln(filterNameStartWithDAndPragprogInFeed.size)\n运行结果\n# of feeds with auth name D* and pragprog in URL: 1\nUsingCollections/PlayingWithMap.scala\nprintln(s\"Get Andy's Feed: ${feeds.get(\"Andy Hunt\")}\")\nprintln(s\"Get Bill's Feed: ${feeds.get(\"Bill Who\")}\")\n运行结果\nGet Andy's Feed: Some(blog.toolshed.com)\nGet Bill's Feed: None\nUsingCollections/PlayingWithMap.scala\ntry {\n  println(s\"Get Andy's Feed Using apply(): ${feeds(\"Andy Hunt\")}\")\n  print(\"Get Bill's Feed: \")\n  println(feeds(\"Bill Who\"))\n} catch {\n  case _: java.util.NoSuchElementException => println(\"Not found\")\n}\n运行结果\nGet Andy's Feed Using apply(): blog.toolshed.com\nGet Bill's Feed: Not found\nUsingCollections/PlayingWithMap.scala\nval newFeeds1 = feeds.updated(\"Venkat Subramaniam\", \"blog.agiledeveloper.com\")\nprintln(\"Venkat's blog in original feeds: \" + feeds.get(\"Venkat Subramaniam\"))\nprintln(\"Venkat's blog in new feed: \" + newFeeds1(\"Venkat Subramaniam\"))\n运行结果\nVenkat's blog in original feeds: None\nVenkat's blog in new feed: blog.agiledeveloper.com\nUsingCollections/PlayingWithMap.scala\nval mutableFeeds = scala.collection.mutable.Map(\"Scala Book Forum\" -> \"forums.pragprog.com/forums/87\")\nmutableFeeds(\"Groovy Book Forum\") = \"forums.pragprog.com/forums/246\"\nprintln(s\"Number of forums: ${mutableFeeds.size}\")\n运行结果\nNumber of forums: 2","title":"8.3 关联映射"},{"location":"/chapter-08/index.html#8-4-不可变列表","text":"UsingCollections/PlayingWithList.scala\nval feeds = List(\"blog.toolshed.com\", \"pragdave.me\", \"blog.agiledeveloper.com\")\nUsingCollections/PlayingWithList.scala\nprintln(s\"First feed: ${feeds.head}\")\nprintln(s\"Second feed: ${feeds(1)}\")\n运行结果\nFirst feed: blog.toolshed.com\nSecond feed: pragdave.me\nUsingCollections/PlayingWithList.scala\nval prefixedList = \"forums.pragprog.com/forums/87\" :: feeds\nprintln(s\"First Feed In Prefixed: ${prefixedList.head}\")\n运行结果\nFirst Feed In Prefixed: forums.pragprog.com/forums/87\nUsingCollections/PlayingWithList.scala\nval feedsWithForums =\n  feeds ::: List(\"forums.pragprog.com/forums/87\", \"forums.pragprog.com/forums/246\")\nprintln(s\"First feed in feeds with forum: ${feedsWithForums.head}\")\nprintln(s\"Last feed in feeds with forum: ${feedsWithForums.last}\")\n运行结果\nFirst feed in feeds with forum: blog.toolshed.com\nLast feed in feeds with forum: forums.pragprog.com/forums/246\nUsingCollections/PlayingWithList.scala\nval appendedList = feeds ::: List(\"agilelearner.com\")\nprintln(s\"Last Feed In Appended: ${appendedList.last}\")\n运行结果\nLast Feed In Appended: agilelearner.com\nUsingCollections/PlayingWithList.scala\nprintln(s\"Feeds with blog: ${feeds.filter(_ contains \"blog\").mkString(\", \")}\")\nprintln(s\"All feeds have com: ${feeds.forall(_ contains \"com\")}\")\nprintln(s\"All feeds have dave: ${feeds.forall(_ contains \"dave\")}\")\nprintln(s\"Any feed has dave: ${feeds.exists(_ contains \"dave\")}\")\nprintln(s\"Any feed has bill: ${feeds.exists(_ contains \"bill\")}\")\n运行结果\nFeeds with blog: blog.toolshed.com, blog.agiledeveloper.com\nAll feeds have com: false\nAll feeds have dave: false\nAny feed has dave: true\nAny feed has bill: false\nUsingCollections/PlayingWithList.scala\nprintln(s\"Feed url lengths: ${feeds.map(_.length).mkString(\", \")}\")\n运行结果\nFeed url lengths: 17, 11, 23\nUsingCollections/PlayingWithList.scala\nval total = feeds.foldLeft(0) { (total, feed) =>\n  total + feed.length\n}\nprintln(s\"Total length of feed urls: $total\")\n运行结果\nTotal length of feed urls: 51\nUsingCollections/PlayingWithList.scala\nval total2 = (0 /: feeds) { (total, feed) =>\n  total + feed.length\n}\nprintln(s\"Total length of feed urls: $total2\")\n运行结果\nTotal length of feed urls: 51\nUsingCollections/PlayingWithList.scala\nval total3 = (0 /: feeds) { _ + _.length }\nprintln(s\"Total length of feed urls: $total3\")\n运行结果\nTotal length of feed urls: 51","title":"8.4 不可变列表"},{"location":"/chapter-08/index.html#8-5-方法名约定","text":"UsingCollections/Colon.scala\nclass Cow {\n  def ^(moon: Moon): Unit = println(\"Cow jumped over the moon\")\n}\nclass Moon {\n  def ^:(cow: Cow): Unit = println(\"This cow jumped over the moon too\")\n}\nUsingCollections/Colon.scala\nval cow = new Cow\nval moon = new Moon\n\ncow ^ moon\ncow ^: moon\n运行结果\nCow jumped over the moon\nThis cow jumped over the moon too\nUsingCollections/Unary.scala\nclass Sample {\n  def unary_+(): Unit = println(\"Called unary +\")\n  def unary_-(): Unit = println(\"called unary -\")\n  def unary_!(): Unit = println(\"called unary !\")\n  def unary_~(): Unit = println(\"called unary ~\")\n}\n\nval sample = new Sample\n+sample\n-sample\n!sample\n~sample\n运行结果\nCalled unary +\ncalled unary -\ncalled unary !\ncalled unary ~","title":"8.5 方法名约定"},{"location":"/chapter-08/index.html#8-6-for-表达式","text":"UsingCollections/PowerOfFor.scala\nfor (_ <- 1 to 3) { print(\"ho \") }\nUsingCollections/PowerOfFor.scala\nval result =\n  for (i <- 1 to 10)\n    yield i * 2\nUsingCollections/PowerOfFor.scala\nval result2 = (1 to 10).map(_ * 2)\nUsingCollections/PowerOfFor.scala\nval doubleEven =\n  for (i <- 1 to 10; if i % 2 == 0)\n    yield i * 2\nUsingCollections/PowerOfFor.scala\nfor {\n  i <- 1 to 10\n  if i % 2 == 0\n} yield i * 2\nUsingCollections/Friends.scala\nclass Person(val firstName: String, val lastName: String)\nobject Person {\n  def apply(firstName: String, lastName: String): Person =\n    new Person(firstName, lastName)\n}\nval friends =\n  List(Person(\"Brian\", \"Sletten\"), Person(\"Neal\", \"Ford\"), Person(\"Scott\", \"Davis\"), Person(\"Stuart\", \"Halloway\"))\n\nval lastNames =\n  for (friend <- friends; lastName = friend.lastName) yield lastName\n\nprintln(lastNames.mkString(\", \"))\n运行结果\nSletten, Ford, Davis, Halloway\nUsingCollections/MultipleLoop.scala\nfor (i <- 1 to 3; j <- 4 to 6) {\n  print(s\"[$i,$j] \")\n}\n运行结果\n[1,4] [1,5] [1,6] [2,4] [2,5] [2,6] [3,4] [3,5] [3,6]","title":"8.6 for 表达式"},{"location":"/chapter-09/index.html","text":"","title":"第9章——模式匹配和正则表达式 ·"},{"location":"/chapter-09/index.html#第9章-模式匹配和正则表达式","text":"模式匹配（pattern matching）在 Scala 被广泛使用的特性中排在第二位，仅次于函数值和 闭包。Scala 对于模式匹配的出色支持意味着，在并发编程中在处理 Actor 接收到的消息时， 将会大量地使用它。在本章中，我们将学到 Scala 的模式匹配的机制、case 类和提取器，以 及如何创建和使用正则表达式。","title":"第9章——模式匹配和正则表达式"},{"location":"/chapter-09/index.html#9-1-模式匹配综述","text":"PatternMatching/MatchLiterals.scala\ndef activity(day: String): Unit = {\n  day match {\n    case \"Sunday\" => print(\"Eat, sleep, repeat... \")\n    case \"Saturday\" => print(\"Hang out with friends... \")\n    case \"Monday\" => print(\"...code for fun...\")\n    case \"Friday\" => print(\"...read a good book...\")\n  }\n}\nList(\"Monday\", \"Sunday\", \"Saturday\").foreach { activity }\n运行结果\n...code for fun...Eat, sleep, repeat... Hang out with friends...\nPatternMatching/Wildcard.scala\nobject DayOfWeek extends Enumeration {\n  val SUNDAY: DayOfWeek.Value = Value(\"Sunday\")\n  val MONDAY: DayOfWeek.Value = Value(\"Monday\")\n  val TUESDAY: DayOfWeek.Value = Value(\"Tuesday\")\n  val WEDNESDAY: DayOfWeek.Value = Value(\"Wednesday\")\n  val THURSDAY: DayOfWeek.Value = Value(\"Thursday\")\n  val FRIDAY: DayOfWeek.Value = Value(\"Friday\")\n  val SATURDAY: DayOfWeek.Value = Value(\"Saturday\")\n}\n\ndef activity(day: DayOfWeek.Value): Unit = {\n  day match {\n    case DayOfWeek.SUNDAY => println(\"Eat, sleep, repeat...\")\n    case DayOfWeek.SATURDAY => println(\"Hang out with friends\")\n    case _ => println(\"...code for fun...\")\n  }\n}\n\nactivity(DayOfWeek.SATURDAY)\nactivity(DayOfWeek.MONDAY)\n运行结果\nHang out with friends\n...code for fun...\nPatternMatching/MatchTuples.scala\ndef processCoordinates(input: Any): Unit = {\n  input match {\n    case (lat, long) => printf(\"Processing (%d, %d)...\", lat, long)\n    case \"done\" => println(\"done\")\n    case _ => println(\"invalid input\")\n  }\n}\n\nprocessCoordinates((39, -104))\nprocessCoordinates(\"done\")\n运行结果\nProcessing (39, -104)...done\nPatternMatching/MatchList.scala\ndef processItems(items: List[String]): Unit = {\n  items match {\n    case List(\"apple\", \"ibm\") => println(\"Apples and IBMs\")\n    case List(\"red\", \"blue\", \"white\") => println(\"Stars and Stripes...\")\n    case List(\"red\", \"blue\", _*) => println(\"colors red, blue,... \")\n    case List(\"apple\", \"orange\", otherFruits @ _*) =>\n      println(\"apples, oranges, and \" + otherFruits)\n  }\n}\n\nprocessItems(List(\"apple\", \"ibm\"))\nprocessItems(List(\"red\", \"blue\", \"green\"))\nprocessItems(List(\"red\", \"blue\", \"white\"))\nprocessItems(List(\"apple\", \"orange\", \"grapes\", \"dates\"))\n运行结果\nApples and IBMs\ncolors red, blue,... \nStars and Stripes...\napples, oranges, and List(grapes, dates)\nPatternMatching/MatchTypes.scala\ndef process(input: Any): Unit = {\n  input match {\n    case (_: Int, _: Int) => print(\"Processing (int, int)... \")\n    case (_: Double, _: Double) => print(\"Processing (double, double)... \")\n    case msg: Int if msg > 1000000 => println(\"Processing int > 1000000\")\n    case _: Int => print(\"Processing int... \")\n    case _: String => println(\"Processing string... \")\n    case _ => printf(s\"Can't handle $input... \")\n  }\n}\n\nprocess((34.2, -159.3))\nprocess(0)\nprocess(1000001)\nprocess(2.2)\n运行结果\nProcessing (double, double)... Processing int... Processing int > 1000000\nCan't handle 2.2...","title":"9.1 模式匹配综述"},{"location":"/chapter-09/index.html#9-2-case-表达式中的模式变量和常量","text":"PatternMatching/MatchWithField.scala\nclass Sample {\n  val max = 100\n\n  def process(input: Int): Unit = {\n    input match {\n      case max => println(s\"You matched max $max\")\n    }\n  }\n}\n\nval sample = new Sample\ntry {\n  sample.process(0)\n} catch {\n  case ex: Throwable => println(ex)\n}\nsample.process(100)\n运行结果\nYou matched max 0\nYou matched max 100\nPatternMatching/MatchWithField1.scala\ncase this.max => println(s\"You matched max $max\")\n运行结果\nscala.MatchError: 0 (of class java.lang.Integer)\nYou matched max 100\nPatternMatching/MatchWithField2.scala\ncase `max` => println(s\"You matched max $max\")\n运行结果\nscala.MatchError: 0 (of class java.lang.Integer)\nYou matched max 100\nPatternMatching/MatchWithValsOK.scala\nclass Sample {\n  val MAX = 100\n\n  def process(input: Int): Unit = {\n    input match {\n      case MAX => println(\"You matched max\")\n    }\n  }\n}\n\nval sample = new Sample\ntry {\n  sample.process(0)\n} catch {\n  case ex: Throwable => println(ex)\n}\nsample.process(100)\n运行结果\nscala.MatchError: 0 (of class java.lang.Integer)\nYou matched max","title":"9.2 case 表达式中的模式变量和常量"},{"location":"/chapter-09/index.html#9-3-使用-case-类进行模式匹配","text":"PatternMatching/TradeStock.scala\ntrait Trade\ncase class Sell(stockSymbol: String, quantity: Int) extends Trade\ncase class Buy(stockSymbol: String, quantity: Int) extends Trade\ncase class Hedge(stockSymbol: String, quantity: Int) extends Trade\nPatternMatching/TradeStock.scala\nobject TradeProcessor {\n  def processTransaction(request: Trade): Unit = {\n    request match {\n      case Sell(stock, 1000) => println(s\"Selling 1000-units of $stock\")\n      case Sell(stock, quantity) =>\n        println(s\"Selling $quantity units of $stock\")\n      case Buy(stock, quantity) if quantity > 2000 =>\n        println(s\"Buying $quantity (large) units of $stock\")\n      case Buy(stock, quantity) =>\n        println(s\"Buying $quantity units of $stock\")\n    }\n  }\n}\nPatternMatching/TradeStock.scala\nTradeProcessor.processTransaction(Sell(\"GOOG\", 500))\nTradeProcessor.processTransaction(Buy(\"GOOG\", 700))\nTradeProcessor.processTransaction(Sell(\"GOOG\", 1000))\nTradeProcessor.processTransaction(Buy(\"GOOG\", 3000))\n运行结果\nSelling 500 units of GOOG\nBuying 700 units of GOOG\nSelling 1000-units of GOOG\nBuying 3000 (large) units of GOOG\nPatternMatching/ThingsAcceptor.scala\ncase class Apple()\ncase class Orange()\ncase class Book()\n\nobject ThingsAcceptor {\n  def acceptStuff(thing: Any): Unit = {\n    thing match {\n      case Apple() => println(\"Thanks for the Apple\")\n      case Orange() => println(\"Thanks for the Orange\")\n      case Book() => println(\"Thanks for the Book\")\n      case _ => println(s\"Excuse me, why did you send me $thing\")\n    }\n  }\n}\nPatternMatching/ThingsAcceptor.scala\nThingsAcceptor.acceptStuff(Apple())\nThingsAcceptor.acceptStuff(Book())\nThingsAcceptor.acceptStuff(Apple)\n运行结果\nThanks for the Apple\nThanks for the Book\nExcuse me, why did you send me Apple\nPatternMatching/ThingsAcceptor2.scala\nabstract class Thing\ncase class Apple() extends Thing\n\nobject ThingsAcceptor {\n  def acceptStuff(thing: Thing) {\n    thing match {\n      //...\n      case _ =>\n    }\n  }\n}\n\nThingsAcceptor.acceptStuff(Apple) //error: type mismatch;","title":"9.3 使用 case 类进行模式匹配"},{"location":"/chapter-09/index.html#9-4-提取器和正则表达式","text":"PatternMatching/Extractor1.scala\nStockService.process(\"GOOG\")\nStockService.process(\"IBM\")\nStockService.process(\"ERR\")\nPatternMatching/Extractor1.scala\nobject StockService {\n  def process(input: String): Unit = {\n    input match {\n      case Symbol() => println(s\"Look up price for valid symbol $input\")\n      case _ => println(s\"Invalid input $input\")\n    }\n  }\n}\nPatternMatching/Extractor1.scala\nobject Symbol {\n  def unapply(symbol: String): Boolean = {\n    // you'd look up a database... here only GOOG and IBM are recognized\n    symbol == \"GOOG\" || symbol == \"IBM\"\n  }\n}\n运行结果\nLook up price for valid symbol GOOG\nLook up price for valid symbol IBM\nInvalid input ERR\nPatternMatching/Extractor.scala\nobject StockService {\n  def process(input: String): Unit = {\n    input match {\n      case Symbol() => println(s\"Look up price for valid symbol $input\")\n      case ReceiveStockPrice(symbol, price) =>\n        println(s\"Received price $$$price for symbol $symbol\")\n      case _ => println(s\"Invalid input $input\")\n    }\n  }\n}\nPatternMatching/Extractor.scala\nobject ReceiveStockPrice {\n  def unapply(input: String): Option[(String, Double)] = {\n    try {\n      if (input contains \":\") {\n        val splitQuote = input.split(\":\")\n        Some((splitQuote(0), splitQuote(1).toDouble))\n      } else {\n        None\n      }\n    } catch {\n      case _: NumberFormatException => None\n    }\n  }\n}\nPatternMatching/Extractor.scala\nStockService.process(\"GOOG\")\nStockService.process(\"GOOG:310.84\")\nStockService.process(\"GOOG:BUY\")\nStockService.process(\"ERR:12.21\")\n运行结果\nLook up price for valid symbol GOOG\nReceived price $310.84 for symbol GOOG\nInvalid input GOOG:BUY\nReceived price $12.21 for symbol ERR\nPatternMatching/Extractor2.scala\ncase ReceiveStockPrice(symbol @ Symbol(), price) =>\n  println(s\"Received price $$$price for symbol $symbol\")\n运行结果\nLook up price for valid symbol GOOG\nReceived price $310.84 for symbol GOOG\nInvalid input GOOG:BUY\nInvalid input ERR:12.21\nPatternMatching/RegularExpr.scala\nval pattern = \"(S|s)cala\".r\nval str = \"Scala is scalable and cool\"\nprintln(pattern.findFirstIn(str))\nPatternMatching/RegularExpr.scala\nprintln(pattern.findAllIn(str).mkString(\", \"))\nPatternMatching/RegularExpr.scala\nprintln(\"cool\".r.replaceFirstIn(str, \"awesome\"))\n运行结果\nSome(Scala)\nScala, scala\nScala is scalable and awesome\nPatternMatching/MatchUsingRegex.scala\ndef process(input: String): Unit = {\n  val GoogStock = \"\"\"^GOOG:(\\d*\\.\\d+)\"\"\".r\n  input match {\n    case GoogStock(price) => println(s\"Price of GOOG is $$$price\")\n    case _ => println(s\"not processing $input\")\n  }\n}\nprocess(\"GOOG:310.84\")\nprocess(\"GOOG:310\")\nprocess(\"IBM:84.01\")\n运行结果\nPrice of GOOG is $310.84\nnot processing GOOG:310\nnot processing IBM:84.01\nPatternMatching/MatchUsingRegex2.scala\ndef process(input: String): Unit = {\n  val MatchStock = \"\"\"^(.+):(\\d*\\.\\d+)\"\"\".r\n  input match {\n    case MatchStock(\"GOOG\", price) => println(s\"We got GOOG at $$$price\")\n    case MatchStock(\"IBM\", price) => println(s\"IBM's trading at $$$price\")\n    case MatchStock(symbol, price) => println(s\"Price of $symbol is $$$price\")\n    case _ => println(s\"not processing $input\")\n  }\n}\nprocess(\"GOOG:310.84\")\nprocess(\"IBM:84.01\")\nprocess(\"GE:15.96\")\n运行结果\nWe got GOOG at $310.84\nIBM's trading at $84.01\nPrice of GE is $15.96","title":"9.4 提取器和正则表达式"},{"location":"/chapter-10/index.html","text":"","title":"第10章——处理异常 ·"},{"location":"/chapter-10/index.html#第10章-处理异常","text":"Java 的受检异常（checked exception）会强制开发人员捕获错误，包括那些开发人员并不关 心的，因此 Java 程序员经常会写一个空的 catch 代码块来抑制相关的异常，而不是将其引渡至 合理的位置上进行处理。Scala 不这样做。它让开发人员只处理自己关心的异常，并忽略其他异 常。这些没有处理的异常将会自动地传播。在本章中，我们将学到如何在 Scala 中处理异常。","title":"第10章——处理异常"},{"location":"/chapter-10/index.html#10-1-scala-中的异常","text":"ExceptionHandling/Throw.scala\nthrow new IllegalArgumentException\nExceptionHandling/JavaThreadSleep.java\n// Java code\ntry {\n  Thread.sleep(1000);\n}                    \ncatch(InterruptedException ex) {\n  // Losing sleep over what to do here?\n}\nExceptionHandling/ThreadSleep.scala\nThread.sleep(1000)\nExceptionHandling/Tax.scala\nobject Tax {\n  def taxFor(amount: Double): Double = {\n    if (amount < 0)\n      throw new IllegalArgumentException(\"Amount must be greater than zero\")\n\n    if (amount < 0.01)\n      throw new RuntimeException(\"Amount too small to be taxed\")\n\n    if (amount > 1000000) throw new Exception(\"Amount too large...\")\n\n    amount * 0.08\n  }\n}\nExceptionHandling/ExceptionHandling.scala\nfor (amount <- List(100.0, 0.009, -2.0, 1000001.0)) {\n  try {\n    print(s\"Amount: $$$amount \")\n    println(s\"Tax: $$${Tax.taxFor(amount)}\")\n  } catch {\n    case ex: IllegalArgumentException => println(ex.getMessage)\n    case ex: RuntimeException =>\n      // if you need a block of code to handle exception\n      println(s\"Don't bother reporting...${ex.getMessage}\")\n  }\n}\n运行结果\nAmount: $100.0 Tax: $8.0\nAmount: $0.009 Don't bother reporting...Amount too small to be taxed\nAmount: $-2.0 Amount must be greater than zero\nAmount: $1000001.0 java.lang.Exception: Amount too large...\n\tat Tax$.taxFor(Tax.scala:9)\n...\nExceptionHandling/CatchAll.scala\nfor (amount <- List(100.0, 0.009, -2.0, 1000001.0)) {\n  try {\n    print(s\"Amount: $$$amount \")\n    println(s\"Tax: $$${Tax.taxFor(amount)}\")\n  } catch {\n    case ex: IllegalArgumentException => println(ex.getMessage)\n    case _: Throwable => println(\"Something went wrong\")\n  }\n}\n运行结果\nAmount: $100.0 Tax: $8.0\nAmount: $0.009 Something went wrong\nAmount: $-2.0 Amount must be greater than zero\nAmount: $1000001.0 Something went wrong","title":"10.1 Scala 中的异常"},{"location":"/chapter-10/index.html#10-2-注意-catch-的顺序","text":"ExceptionHandling/JavaCatchOrder.java\n// Java code—will not compile due to incorrect catch order\npublic class JavaCatchOrder {\n  public void catchOrderExample() {\n    try {\n      String str = \"hello\";\n      System.out.println(str.charAt(31));\n    } catch (Exception ex) {\n      System.out.println(\"Exception caught\");\n    } catch (StringIndexOutOfBoundsException ex) { // ERROR\n      System.out.println(\"Invalid Index\");\n    }\n  }\n}\n运行结果\nJavaCatchOrder.java:10: error: exception StringIndexOutOfBoundsException\nhas already been caught\n    catch(StringIndexOutOfBoundsException ex) { //ERROR\n    ^\n1 error\nExceptionHandling/CatchOrder.scala\nval amount = -2\ntry {\n  print(s\"Amount: $$$amount \")\n  println(s\"Tax: $$${Tax.taxFor(amount)}\")\n} catch {\n  case _: Exception => println(\"Something went wrong\")\n  case ex: IllegalArgumentException => println(ex.getMessage)\n}\n运行结果\nAmount: $-2 Something went wrong","title":"10.2 注意 catch 的顺序"},{"location":"/chapter-11/index.html","text":"","title":"第11章——递归编程 ·"},{"location":"/chapter-11/index.html#第11章-递归编程","text":"使用解决子问题的方案解决一个问题，也就是递归，这种想法十分诱人。许多算法和 问题本质上都是递归的。一旦我们找到窍门，使用递归来设计解决方案就变得极富表现力 且直观。","title":"第11章——递归编程"},{"location":"/chapter-11/index.html#11-1-一个简单的递归","text":"ProgrammingRecursions/Factorial.scala\ndef factorial(number: Int): BigInt = {\n  if (number == 0)\n    1\n  else\n    number * factorial(number - 1)\n}\n运行结果\n120\nProgrammingRecursions/Factorial.scala\nprintln(factorial(5))\nProgrammingRecursions/Factorial.scala\nprintln(factorial(10000))\n运行结果\njava.lang.StackOverflowError","title":"11.1 一个简单的递归"},{"location":"/chapter-11/index.html#11-2-尾调用优化-tco-","text":"ProgrammingRecursions/Mad.scala\ndef mad(parameter: Int): Int = {\n  if (parameter == 0)\n    throw new RuntimeException(\"Error\")\n  else\n    1 * mad(parameter - 1)\n}\n\nmad(5)\n运行结果\njava.lang.RuntimeException: Error\n\tat Main$$anon$1.mad(mad.scala:3)\n\tat Main$$anon$1.mad(mad.scala:5)\n\tat Main$$anon$1.mad(mad.scala:5)\n\tat Main$$anon$1.mad(mad.scala:5)\n\tat Main$$anon$1.mad(mad.scala:5)\n\tat Main$$anon$1.mad(mad.scala:5)\n\tat Main$$anon$1.<init>(mad.scala:8)\nProgrammingRecursions/Mad2.scala\ndef mad(parameter: Int): Int = {\n  if (parameter == 0)\n    throw new RuntimeException(\"Error\")\n  else\n    mad(parameter - 1)\n}\n\nmad(5)\n运行结果\njava.lang.RuntimeException: Error\n\tat Main$$anon$1.mad(mad2.scala:3)\n\tat Main$$anon$1.<init>(mad2.scala:8)\nprivate int mad(int);\n    Code:\n       0: iload_1\n       1: iconst_0\n       2: if_icmpne     15\n       5: new           #14                 // class \njava/lang/RuntimeException\n       8: dup\n       9: ldc           #16                 // String Error\n      11: invokespecial #20                 // Method \njava/lang/RuntimeException.\"<init>\":(Ljava/lang/String;)V\n      14: athrow\n      15: iconst_1\n      16: aload_0\n      17: iload_1\n      18: iconst_1\n      19: isub\n      20: invokespecial #22                 // Method mad:(I)I\n      23: imul\n      24: ireturn\nprivate int mad(int);\n    Code:\n       0: iload_1\n       1: iconst_0\n       2: if_icmpne     15\n       5: new           #14                 // class \njava/lang/RuntimeException\n       8: dup\n       9: ldc           #16                 // String Error\n      11: invokespecial #20                 // Method \njava/lang/RuntimeException.\"<init>\":(Ljava/lang/String;)V\n      14: athrow\n      15: iload_1\n      16: iconst_1\n      17: isub\n      18: istore_1\n      19: goto          0\nProgrammingRecursions/FactorialNoTCO.scala\n@scala.annotation.tailrec\ndef factorial(number: Int): BigInt = {\n  if (number == 0)\n    1\n  else\n    number * factorial(number - 1)\n}\n\nprintln(factorial(10000))\n运行结果\nerror: could not optimize @tailrec annotated method factorial: it contains\na recursive call not in tail position\n    number * factorial(number - 1)\n           ^\nerror found\nProgrammingRecursions/FactorialTCO.scala\n@scala.annotation.tailrec\ndef factorial(fact: BigInt, number: Int): BigInt = {\n  if (number == 0)\n    fact\n  else\n    factorial(fact * number, number - 1)\n}\n\nprintln(factorial(1, 10000))\n运行结果\n284625968091705451890641321211986889014805140170279923079417999427441134000\n...","title":"11.2 尾调用优化（TCO）"},{"location":"/chapter-11/index.html#11-3-蹦床调用","text":"ProgrammingRecursions/Words.scala\nimport scala.io.Source._\n\ndef explore(count: Int, words: List[String]): Int =\n  if (words.isEmpty)\n    count\n  else\n    countPalindrome(count, words)\n\ndef countPalindrome(count: Int, words: List[String]): Int = {\n  val firstWord = words.head\n\n  if (firstWord.reverse == firstWord)\n    explore(count + 1, words.tail)\n  else\n    explore(count, words.tail)\n}\n\ndef callExplore(text: String): Unit = println(explore(0, text.split(\" \").toList))\n\ncallExplore(\"dad mom and racecar\")\n\ntry {\n  val text =\n    fromURL(\"https://en.wikipedia.org/wiki/Gettysburg_Address\").mkString\n  callExplore(text)\n} catch {\n  case ex: Throwable => println(ex)\n}\n运行结果\n3\njava.lang.StackOverflowError\nProgrammingRecursions/WordsTrampoline.scala\nimport scala.io.Source._\nimport scala.util.control.TailCalls._\n\ndef explore(count: Int, words: List[String]): TailRec[Int] =\n  if (words.isEmpty)\n    done(count)\n  else\n    tailcall(countPalindrome(count, words))\n\ndef countPalindrome(count: Int, words: List[String]): TailRec[Int] = {\n  val firstWord = words.head\n\n  if (firstWord.reverse == firstWord)\n    tailcall(explore(count + 1, words.tail))\n  else\n    tailcall(explore(count, words.tail))\n}\n\ndef callExplore(text: String): Unit =\n  println(explore(0, text.split(\" \").toList).result)\n\ncallExplore(\"dad mom and racecar\")\n\ntry {\n  val text =\n    fromURL(\"https://en.wikipedia.org/wiki/Gettysburg_Address\").mkString\n  callExplore(text)\n} catch {\n  case ex: Throwable => println(ex)\n}\n运行结果\n3\n352","title":"11.3 蹦床调用"},{"location":"/part3.html","text":"","title":"第三部分 Scala 中的并发编程 ·"},{"location":"/part3.html#第三部分-scala-中的并发编程","text":"并发编程是意外的复杂性之一。 ① Scala 提供了一些优雅的解决方案。读者将了解：\n惰性求值有哪些优势； ② 严格集合和惰性集合之间有哪些差异 ； 如何使用并行集合； 如何避免共享的可变性； 如何使用 Actor 进行并发编程 ③ 。\n指并发编程本来不应该如此复杂。—译者注 可以和求值策略进行对照。—译者注 在本书中将使用 Akka 套件。—译者注","title":"第三部分 Scala 中的并发编程"},{"location":"/chapter-12/index.html","text":"","title":"第12章——惰性求值和并行集合 ·"},{"location":"/chapter-12/index.html#第12章-惰性求值和并行集合","text":"即时响应性是一项决定任何应用程序成败的关键因素。其他因素，如商业价值、易用性、 可用性、成本以及回弹性，也很重要，但是即时响应性是最重要的—我们人类大约需要 250 ms 来感知任何的移动，超过 5 s 的延迟就变得不可接受了。任何可以降低响应时间的努力都会 产生巨大的影响，能够使客户更加满意，进而赢得他们的信任。","title":"第12章——惰性求值和并行集合"},{"location":"/chapter-12/index.html#12-1-释放惰性","text":"Parallel/ShortCircuit.scala\ndef expensiveComputation() = {\n  println(\"...assume slow operation...\")\n  false\n}\n\ndef evaluate(input: Int): Unit = {\n  println(s\"evaluate called with $input\")\n  if (input >= 10 && expensiveComputation())\n    println(\"doing work...\")\n  else\n    println(\"skipping\")\n}\n\nevaluate(0)\nevaluate(100)\n运行结果\nevaluate called with 0\nskipping\nevaluate called with 100\n...assume slow operation...\nskipping\nParallel/Eager.scala\nval perform = expensiveComputation()\nif (input >= 10 && perform)\n运行结果\nevaluate called with 0\n...assume slow operation...\nskipping\nevaluate called with 100\n...assume slow operation...\nskipping\nParallel/Eager.scala\n@volatile lazy val perform = expensiveComputation()\nif (input >= 10 && perform)\n  println(\"doing work...\")\n运行结果\nevaluate called with 0\nskipping\nevaluate called with 100\n...assume slow operation...\nskipping\nParallel/LazyOrder.scala\nimport scala.io._\n\ndef read = StdIn.readInt()\n\n@volatile lazy val first = read\n@volatile lazy val second = read\n\nif (Math.random() < 0.5)\n  second\n\nprintln(first - second)\n运行结果\n> scala LazyOrder.scala\n1\n2\n1\n> scala LazyOrder.scala\n1\n2\n-1\n>","title":"12.1 释放惰性"},{"location":"/chapter-12/index.html#12-2-释放严格集合的惰性","text":"Parallel/StrictCollection.scala\nval people = List(\n  (\"Mark\", 32),\n  (\"Bob\", 22),\n  (\"Jane\", 8),\n  (\"Jill\", 21),\n  (\"Nick\", 50),\n  (\"Nancy\", 42),\n  (\"Mike\", 19),\n  (\"Sara\", 12),\n  (\"Paula\", 42),\n  (\"John\", 21))\n\ndef isOlderThan17(person: (String, Int)) = {\n  println(s\"isOlderThan17 called for $person\")\n  val (_, age) = person\n  age > 17\n}\n\ndef isNameStartsWithJ(person: (String, Int)) = {\n  println(s\"isNameStartsWithJ called for $person\")\n  val (name, _) = person\n  name.startsWith(\"J\")\n}\n\nprintln(people.filter { isOlderThan17 }.filter { isNameStartsWithJ }.head)\n运行结果\nisOlderThan17 called for (Mark,32)\nisOlderThan17 called for (Bob,22)\nisOlderThan17 called for (Jane,8)\nisOlderThan17 called for (Jill,21)\nisOlderThan17 called for (Nick,50)\nisOlderThan17 called for (Nancy,42)\nisOlderThan17 called for (Mike,19)\nisOlderThan17 called for (Sara,12)\nisOlderThan17 called for (Paula,42)\nisOlderThan17 called for (John,21)\nisNameStartsWithJ called for (Mark,32)\nisNameStartsWithJ called for (Bob,22)\nisNameStartsWithJ called for (Jill,21)\nisNameStartsWithJ called for (Nick,50)\nisNameStartsWithJ called for (Nancy,42)\nisNameStartsWithJ called for (Mike,19)\nisNameStartsWithJ called for (Paula,42)\nisNameStartsWithJ called for (John,21)\n(Jill,21)\nParallel/LazyCollection.scala\nprintln(people.view.filter { isOlderThan17 }.filter { isNameStartsWithJ }.head)\n运行结果\nisOlderThan17 called for (Mark,32)\nisNameStartsWithJ called for (Mark,32)\nisOlderThan17 called for (Bob,22)\nisNameStartsWithJ called for (Bob,22)\nisOlderThan17 called for (Jane,8)\nisOlderThan17 called for (Jill,21)\nisNameStartsWithJ called for (Jill,21)\n(Jill,21)","title":"12.2 释放严格集合的惰性"},{"location":"/chapter-12/index.html#12-3-终极惰性流","text":"Parallel/NumberGenerator.scala\ndef generate(starting: Int): Stream[Int] = {\n  starting #:: generate(starting + 1)\n}\n\nprintln(generate(25))\n运行结果\nStream(25, ?)\nParallel/NumberGenerator.scala\nprintln(generate(25).take(10).force)\nprintln(generate(25).take(10).toList)\n运行结果\nStream(25, 26, 27, 28, 29, 30, 31, 32, 33, 34)\nList(25, 26, 27, 28, 29, 30, 31, 32, 33, 34)\nParallel/NumberGenerator.scala\nprintln(generate(25).takeWhile { _ < 40 }.force)\n运行结果\nStream(25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39)\nParallel/Primes.scala\ndef isDivisibleBy(number: Int, divisor: Int) = number % divisor == 0\n\ndef isPrime(number: Int) =\n  number > 1 && !(2 until number).exists { isDivisibleBy(number, _) }\n\ndef primes(starting: Int): Stream[Int] = {\n  println(s\"computing for $starting\")\n  if (isPrime(starting))\n    starting #:: primes(starting + 1)\n  else\n    primes(starting + 1)\n}\nParallel/Primes.scala\nval primesFrom100 = primes(100)\n\nprintln(primesFrom100.take(3).toList)\nprintln(\"Let's ask for more...\")\nprintln(primesFrom100.take(4).toList)\n运行结果\ncomputing for 100\ncomputing for 101\ncomputing for 102\ncomputing for 103\ncomputing for 104\ncomputing for 105\ncomputing for 106\ncomputing for 107\nList(101, 103, 107)\nLet's ask for more...\ncomputing for 108\ncomputing for 109\nList(101, 103, 107, 109)","title":"12.3 终极惰性流"},{"location":"/chapter-12/index.html#12-4-并行集合","text":"Parallel/Weather.scala\nimport scala.io.Source\nimport scala.xml._\n\ndef getWeatherData(city: String) = {\n  val response = Source.fromURL(\n    s\"https://raw.githubusercontent.com/ReactivePlatform/\" +\n    s\"Pragmatic-Scala-StaticResources/master/src/main/resources/\" +\n    s\"weathers/$city.xml\")\n  val xmlResponse = XML.loadString(response.mkString)\n  val cityName = (xmlResponse \\\\ \"city\" \\ \"@name\").text\n  val temperature = (xmlResponse \\\\ \"temperature\" \\ \"@value\").text\n  val condition = (xmlResponse \\\\ \"weather\" \\ \"@value\").text\n  (cityName, temperature, condition)\n}\nParallel/Weather.scala\ndef printWeatherData(weatherData: (String, String, String)): Unit = {\n  val (cityName, temperature, condition) = weatherData\n\n  println(f\"$cityName%-15s $temperature%-6s $condition\")\n}\nParallel/Weather.scala\ndef timeSample(getData: List[String] => List[(String, String, String)]): Unit = {\n  val cities = List(\n    \"Houston,us\",\n    \"Chicago,us\",\n    \"Boston,us\",\n    \"Minneapolis,us\",\n    \"Oslo,norway\",\n    \"Tromso,norway\",\n    \"Sydney,australia\",\n    \"Berlin,germany\",\n    \"London,uk\",\n    \"Krakow,poland\",\n    \"Rome,italy\",\n    \"Stockholm,sweden\",\n    \"Bangalore,india\",\n    \"Brussels,belgium\",\n    \"Reykjavik,iceland\")\n\n  val start = System.nanoTime\n  getData(cities).sortBy(_._1).foreach(printWeatherData)\n  val end = System.nanoTime\n  println(s\"Time taken: ${(end - start) / 1.0e9} sec\")\n}\nParallel/Weather.scala\ntimeSample { cities =>\n  cities.map(getWeatherData)\n}\n运行结果\nBengaluru       84.2   few clouds\nBerlin          45.63  broken clouds\nBoston          52.23  scattered clouds\nBrussels        50.83  Sky is Clear\nChicago         46.13  sky is clear\nCracow          40.39  moderate rain\nHouston         54.01  light intensity drizzle\nLondon          55.33  Sky is Clear\nMinneapolis     42.82  sky is clear\nOslo            47.3   Sky is Clear\nReykjavik       31.17  proximity shower rain\nRome            58.42  few clouds\nStockholm       47.28  Sky is Clear\nSydney          68.9   Sky is Clear\nTromso          35.6   proximity shower rain\nTime taken: 67.208944087 sec\nParallel/Weather.scala\nimport scala.collection.parallel.CollectionConverters._\ntimeSample { cities =>\n  cities.par.map(getWeatherData).toList\n}\n运行结果\nBengaluru       84.2   few clouds\nBerlin          45.63  broken clouds\nBoston          52.23  scattered clouds\nBrussels        50.83  Sky is Clear\nChicago         46.13  sky is clear\nCracow          40.39  moderate rain\nHouston         54.01  light intensity drizzle\nLondon          55.33  Sky is Clear\nMinneapolis     42.82  sky is clear\nOslo            47.3   Sky is Clear\nReykjavik       31.17  proximity shower rain\nRome            58.42  few clouds\nStockholm       47.28  Sky is Clear\nSydney          68.9   Sky is Clear\nTromso          35.6   proximity shower rain\nTime taken: 0.171599394 sec","title":"12.4 并行集合"},{"location":"/chapter-13/index.html","text":"","title":"第13章——使用Actor编程 ·"},{"location":"/chapter-13/index.html#第13章-使用actor编程","text":"在编写复杂、耗时的应用程序时，我们经常会使用多线程以及并发来降低响应时间或者 提高性能。可惜，传统的并发解决方案导致了一些问题，如线程安全、竞态条件、死锁、活 锁以及不容易理解的、容易出错的代码。共享的可变性是罪魁祸首。","title":"第13章——使用Actor编程"},{"location":"/chapter-13/index.html#13-1-一个顺序耗时问题","text":"ProgrammingActors/CountFilesSequential.scala\nimport java.io.File\n\ndef getChildren(file: File) = {\n  val children = file.listFiles()\n  if (children != null) children.toList else List()\n}\n\nval start = System.nanoTime\nval exploreFrom = new File(args(0))\n\nvar count = 0L\nvar filesToVisit = List(exploreFrom)\n\nwhile (filesToVisit.nonEmpty) {\n  val head = filesToVisit.head\n  filesToVisit = filesToVisit.tail\n\n  val children = getChildren(head)\n  count = count + children.count { !_.isDirectory }\n  filesToVisit = filesToVisit ::: children.filter { _.isDirectory }\n}\n\nval end = System.nanoTime\nprintln(s\"Number of files found: $count\")\nprintln(s\"Time taken: ${(end - start) / 1.0e9} seconds\")\n执行命令\nscala countFilesSequential.scala /Users/venkats/agility\n运行结果\nNumber of files found: 479758\nTime taken: 66.524453436 seconds","title":"13.1 一个顺序耗时问题"},{"location":"/chapter-13/index.html#13-3-创建-actor","text":"ProgrammingActors/HollywoodActor.scala\nimport akka.actor._\n\nclass HollywoodActor() extends Actor {\n  def receive: Receive = {\n    case message => println(s\"playing the role of $message\")\n  }\n}\n执行命令——编译\nscalac -d classes HollywoodActor.scala CreateActors.scala\n执行命令——执行\nscala -classpath classes CreateActors\nProgrammingActors/CreateActors.scala\nimport akka.actor._\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration.Duration\n\nobject CreateActors extends App {\n  val system = ActorSystem(\"sample\")\n\n  val depp = system.actorOf(Props[HollywoodActor])\n\n  depp ! \"Wonka\"\n\n  val terminateFuture = system.terminate()\n  Await.ready(terminateFuture, Duration.Inf)\n}\n运行结果\nplaying the role of Wonka\nProgrammingActors/HollywoodActor2.scala\ncase message => println(s\"$message - ${Thread.currentThread}\")\nProgrammingActors/CreateActors2.scala\nval depp = system.actorOf(Props[HollywoodActor])\nval hanks = system.actorOf(Props[HollywoodActor])\n\ndepp ! \"Wonka\"\nhanks ! \"Gump\"\n\ndepp ! \"Sparrow\"\nhanks ! \"Phillips\"\nprintln(s\"Calling from ${Thread.currentThread}\")\n运行结果\nWonka - Thread[sample-akka.actor.default-dispatcher-2,5,main]\nGump - Thread[sample-akka.actor.default-dispatcher-3,5,main]\nCalling from Thread[main,5,main]\nPhillips - Thread[sample-akka.actor.default-dispatcher-3,5,main]\nSparrow - Thread[sample-akka.actor.default-dispatcher-2,5,main]","title":"13.3 创建 Actor"},{"location":"/chapter-13/index.html#13-4-actor-和线程","text":"ProgrammingActors/CreateActors3.scala\ndepp ! \"Wonka\"\nhanks ! \"Gump\"\n\nThread.sleep(100)\n\ndepp ! \"Sparrow\"\nhanks ! \"Phillips\"\n运行结果\nWonka - Thread[sample-akka.actor.default-dispatcher-3,5,main]\nGump - Thread[sample-akka.actor.default-dispatcher-4,5,main]\nSparrow - Thread[sample-akka.actor.default-dispatcher-4,5,main]\nPhillips - Thread[sample-akka.actor.default-dispatcher-3,5,main]\nCalling from Thread[main,5,main]","title":"13.4 Actor 和线程"},{"location":"/chapter-13/index.html#13-5-隔离可变性","text":"ProgrammingActors/HollywoodActor4.scala\nimport akka.actor._\nimport scala.collection._\n\ncase class Play(role: String)\ncase class ReportCount(role: String)\n\nclass HollywoodActor() extends Actor {\n  val messagesCount: mutable.Map[String, Int] = mutable.Map()\n\n  def receive: Receive = {\n    case Play(role) =>\n      val currentCount = messagesCount.getOrElse(role, 0)\n      messagesCount.update(role, currentCount + 1)\n      println(s\"Playing $role\")\n\n    case ReportCount(role) =>\n      sender ! messagesCount.getOrElse(role, 0)\n  }\n}\nProgrammingActors/UseActor.scala\nimport akka.actor._\nimport akka.pattern.ask\nimport akka.util.Timeout\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\nobject UseActor extends App {\n\n  case class Play(role: String)\n\n  case class ReportCount(role: String)\n\n  val system = ActorSystem(\"sample\")\n\n  val depp = system.actorOf(Props[HollywoodActor])\n  val hanks = system.actorOf(Props[HollywoodActor])\n\n  depp ! Play(\"Wonka\")\n  hanks ! Play(\"Gump\")\n\n  depp ! Play(\"Wonka\")\n  depp ! Play(\"Sparrow\")\n\n  println(\"Sent roles to play\")\n\n  implicit val timeout: Timeout = Timeout(2.seconds)\n  val wonkaFuture = depp ? ReportCount(\"Wonka\")\n  val sparrowFuture = depp ? ReportCount(\"Sparrow\")\n  val gumpFuture = hanks ? ReportCount(\"Gump\")\n\n  val wonkaCount = Await.result(wonkaFuture, timeout.duration)\n  val sparrowCount = Await.result(sparrowFuture, timeout.duration)\n  val gumpCount = Await.result(gumpFuture, timeout.duration)\n\n  println(s\"Depp played Wonka $wonkaCount time(s)\")\n  println(s\"Depp played Sparrow $sparrowCount time(s)\")\n  println(s\"Hanks played Gump $gumpCount time(s)\")\n\n  val terminateFuture = system.terminate()\n  Await.ready(terminateFuture, Duration.Inf)\n}\n\ncase class Play(role: String)\n\ncase class ReportCount(role: String)\n运行结果\nSent roles to play\nPlaying Wonka\nPlaying Gump\nPlaying Wonka\nPlaying Sparrow\nDepp played Wonka 2 time(s)\nDepp played Sparrow 1 time(s)\nHanks played Gump 1 time(s)","title":"13.5 隔离可变性"},{"location":"/chapter-13/index.html#13-6-使用-actor-模型进行并发","text":"ProgrammingActors/FileExplorer.scala\nimport akka.actor._\nimport java.io._\n\nclass FileExplorer extends Actor {\n  def receive: Receive = {\n    case dirName: String =>\n      val file = new File(dirName)\n      val children = file.listFiles()\n      var filesCount = 0\n\n      if (children != null) {\n        children.filter { _.isDirectory }.foreach { sender ! _.getAbsolutePath }\n        filesCount = children.count { !_.isDirectory }\n      }\n\n      sender ! filesCount\n  }\n}\nProgrammingActors/FilesCounter.scala\nimport akka.actor._\nimport akka.routing._\n\nclass FilesCounter extends Actor {\n  val start: Long = System.nanoTime\n  var filesCount = 0L\n  var pending = 0\n\n  val fileExplorers: ActorRef =\n    context.actorOf(RoundRobinPool(100).props(Props[FileExplorer]))\n\n  def receive: Receive = {\n    case dirName: String =>\n      pending = pending + 1\n      fileExplorers ! dirName\n\n    case count: Int =>\n      filesCount = filesCount + count\n      pending = pending - 1\n\n      if (pending == 0) {\n        val end = System.nanoTime\n        println(s\"Files count: $filesCount\")\n        println(s\"Time taken: ${(end - start) / 1.0e9} seconds\")\n        context.system.terminate()\n      }\n  }\n}\nProgrammingActors/CountFiles.scala\nimport akka.actor._\n\nobject CountFiles extends App {\n  val system = ActorSystem(\"sample\")\n\n  val filesCounter = system.actorOf(Props[FilesCounter])\n\n  filesCounter ! args(0)\n}\n执行命令\nscalac -d classes FilesCounter.scala FileExplorer.scala CountFiles.scala\nscala -classpath classes CountFiles /Users/venkats/agility\n运行结果\nFiles count: 479758\nTime taken: 5.609851764 seconds","title":"13.6 使用 Actor 模型进行并发"},{"location":"/part4.html","text":"","title":"第四部分 Scala 实战 ·"},{"location":"/part4.html#第四部分-scala-实战","text":"现在我们已经知道 Scala 能够为我们做些什么了。让我们在一些实际应用的上下文中使 用 Scala。读者将了解：\n如何在 Java 中使用 Scala； 如何解析和生成 XML； 如何和 Web 服务进行通信； 如何应用并发； 如何使用 ScalaTest 创建单元测试。","title":"第四部分 Scala 实战"},{"location":"/chapter-14/index.html","text":"","title":"第14章——和Java进行互操作 ·"},{"location":"/chapter-14/index.html#第14章-和java进行互操作","text":"现已存在许多强大的 Scala 库，并与日俱增。开发人员不仅可以在 Scala 中使用这些库， 也可以在 Java 中使用它们。但是要做到这一点，必须要学习一些技巧。 ①\n因为某些库可能没有针对潜在的 Java 用户设计友好的 API，所以可能需要一些潜在适配工作。——译者注","title":"第14章——和Java进行互操作"},{"location":"/chapter-14/index.html#14-1-在-scala-中使用-scala-类","text":"Intermixing/Person.scala\nclass Person(val firstName: String, val lastName: String) {\n  override def toString: String = firstName + \" \" + lastName\n}\nIntermixing/Dog.scala\nclass Dog(val name: String) {\n  override def toString: String = name\n}\n执行命令\nscalac Person.scala Dog.scala\njar cf /tmp/example.jar Person.class Dog.class\nIntermixing/UsePerson.scala\nval george = new Person(\"George\", \"Washington\")\n\nval georgesDogs = List(new Dog(\"Captain\"), new Dog(\"Clode\"), new Dog(\"Forester\"), new Dog(\"Searcher\"))\n\nprintln(s\"$george had several dogs ${georgesDogs.mkString(\", \")}...\")\n执行命令\nscala -classpath /tmp/example.jar usePerson.scala\n运行结果\nGeorge Washington had several dogs Captain, Clode, Forester, Searcher...\nIntermixing/UsePersonClass.scala\nobject UsePersonClass extends App {\n  val ben = new Person(\"Ben\", \"Franklin\")\n  println(s\"$ben was a great inventor.\")\n}\n执行命令1\nmkdir -p classes\nscalac -d classes -classpath /tmp/example.jar UsePersonClass.scala\n执行命令2\nscala -classpath classes:/tmp/example.jar UsePersonClass\n执行命令3\njava -classpath $SCALA_HOME/lib/scala-library.jar:classes:/tmp/example.jar \\\n  UsePersonClass\n运行结果\nBen Franklin was a great inventor.","title":"14.1 在 Scala 中使用 Scala 类"},{"location":"/chapter-14/index.html#14-2-在-scala-中使用-java-类","text":"Intermixing/UseJDKClass.scala\nimport java.util.Currency\n\nval currencies = Currency.getAvailableCurrencies\nprintln(s\"${currencies.size} currencies are available.\")\n执行命令\nscala UseJDKClass.scala\n运行结果\n220 currencies are available.\nIntermixing/java/InvestmentType.java\n//Java code\npackage chapter14.usingjava;\n\npublic enum InvestmentType {\n  BOND, STOCK, REAL_ESTATE, COMMODITIES, COLLECTIBLES, MUTUAL_FUNDS\n}\n运行结果\nclass investments.Investment\nIntermixing/java/Investment.java\n//Java code\npackage chapter14.usingjava;\n\npublic class Investment {                                        \n  private String investmentName;\n  private InvestmentType investmentType;\n             \n  public Investment(String name, InvestmentType type) {\n    investmentName = name;\n    investmentType = type;\n  } \n  public int yield() { return 0; }\n}\nIntermixing/UseInvestment.scala\nimport chapter14.usingjava.{ Investment, InvestmentType }\n\nobject UseInvestment extends App {\n  val investment = new Investment(\"XYZ Corporation\", InvestmentType.STOCK)\n  println(investment.getClass)\n}\n执行命令1\nmkdir -p classes\njavac -d classes java/InvestmentType.java java/Investment.java\nscalac -classpath classes UseInvestment.scala\nscala -classpath classes:. UseInvestment\n执行命令2\njava -classpath $SCALA_HOME/lib/scala-library.jar:classes:. UseInvestment\nIntermixing/UseInvestmentError.scala\nval theYield1 = investment.yield   //ERROR\nval theYield2 = investment.yield() //ERROR\nIntermixing/UseInvestmentYield.scala\nval investment = new Investment(\"XYZ Corporation\", InvestmentType.STOCK)\nval theYield1 = investment.`yield`\nval theYield2 = investment.`yield`()","title":"14.2 在 Scala 中使用 Java 类"},{"location":"/chapter-14/index.html#14-3-在-java-中使用-scala-方法","text":"Intermixing/Car.scala\npackage chapter14\n\nclass Car(val year: Int) {\n  private[this] var miles: Int = 0\n\n  def drive(distance: Int): Unit = { miles += distance }\n\n  override def toString: String = s\"year: $year miles: $miles\"\n}\nIntermixing/UseCar.java\n//Java code\npackage chapter14;\n\npublic class UseCar {\n  public static void main(String[] args) {\n    Car car = new Car(2009);\n    \n    System.out.println(car);\n    car.drive(10);\n    System.out.println(car);\n  }\n}\n执行命令\nmkdir -p classes\nscalac -d classes Car.scala\njavac -d classes -classpath $SCALA_HOME/lib/scala-library.jar:classes \\\n  UseCar.java\njava -classpath $SCALA_HOME/lib/scala-library.jar:classes \\\n  automobiles.users.UseCar","title":"14.3 在 Java 中使用 Scala 方法"},{"location":"/chapter-14/index.html#14-4-在-java-中使用特质","text":"Intermixing/Writable.scala\ntrait Writable {\n  def write(message: String): Unit\n}\nIntermixing/AWritableJavaClass.java\n//Java code\npublic class AWritableJavaClass implements Writable {\n  public void write(String message) {\n    //...code...\n  }\n}\nIntermixing/Printable.scala\ntrait Printable {\n  def print(): Unit = {\n    println(\"running printable...\")\n  }\n}\n执行命令1\nmkdir -p classes\nscalac -d classes Printable.scala\n执行命令2\njavap classes/Printable.class classes/Printable\\$class.class\n运行结果\nCompiled from \"Printable.scala\"\npublic abstract class Printable$class {\n  public static void print(Printable);\n  public static void $init$(Printable);\n}\nCompiled from \"Printable.scala\"\npublic abstract class Printable$class {\n  public static void print(Printable);\n  public static void $init$(Printable);\n}\nIntermixing/APrintable.java\npublic class APrintable implements Printable {\n  public void print() {\n    System.out.println(\"We can reuse the trait here if we like...\");\n    //Printable$class.print(this); // for 2.11.x\n    Printable.super.print(); // for 2.12.x\n  }\n  \n  public static void use(Printable printable) {\n    printable.print();\n  }\n  \n  public static void main(String[] args) {\n    APrintable aPrintable = new APrintable();\n    use(aPrintable);\n  }\n}\n执行命令\njavac -d classes -classpath $SCALA_HOME/lib/scala-library.jar:classes \\\n  APrintable.java\njava -classpath $SCALA_HOME/lib/scala-library.jar:classes APrintable\n运行结果\nWe can reuse the trait here if we like...\nrunning printable...","title":"14.4 在 Java 中使用特质"},{"location":"/chapter-14/index.html#14-5-在-java-中使用单例对象和伴生对象","text":"Intermixing/Single.scala\npackage chapter14\n\nobject Single {\n  def greet(): Unit = { println(\"Hello from Single\") }\n}\nIntermixing/SingleUser.java\n//Java code\npublic class SingleUser {\n  public static void main(String[] args) {\n    Single.greet();\n  }\n}\n运行结果\nHello from Single\nIntermixing/Buddy.scala\nclass Buddy {\n  def greet(): Unit = { println(\"Hello from Buddy class\") }\n}\n\nobject Buddy {\n  def greet(): Unit = { println(\"Hello from Buddy object\") }\n}\nIntermixing/BuddyUser.scala\n//Java code\npublic class BuddyUser {\n  public static void main(String[] args) {\n    new Buddy().greet();\n    Buddy$.MODULE$.greet(); \n  }\n}\n运行结果\nHello from Buddy class\nHello from Buddy object","title":"14.5 在 Java 中使用单例对象和伴生对象"},{"location":"/chapter-14/index.html#14-6-扩展类","text":"Intermixing/BirdWithProblem.scala\nabstract class BirdWithProblem {\n  def fly(): Unit\n  //...\n}\nIntermixing/Ostrich.scala\nclass Ostrich extends BirdWithProblem {\n  override def fly(): Unit = {\n    throw new NoFlyException\n  }\n  //...\n}\nIntermixing/NoFlyException.scala\nclass NoFlyException extends Exception {}\nIntermixing/Penguin.java\n//Java code\nclass Penguin extends Bird {      \n  public void fly() throws NoFlyException {\n    throw new NoFlyException();\n  }\n  //...\n}\nPenguin.java:3: error: fly() in Penguin cannot override fly() in Bird\n  public void fly() throws NoFlyException {\n              ^\n  overridden method does not throw NoFlyException\n1 error\nIntermixing/Bird.scala\nabstract class Bird {\n  @throws(classOf[NoFlyException]) def fly(): Unit\n  //...\n}","title":"14.6 扩展类"},{"location":"/chapter-15/index.html","text":"","title":"第15章——使用Scala创建应用程序 ·"},{"location":"/chapter-15/index.html#第15章-使用scala创建应用程序","text":"在本章中，我们将会把在本书中学到的许多东西汇集到一起，并学习一些新东西。我们 将逐步构建一个应用程序，用于找到股票市场中的投资的净值。在这个练习中，我们将会看 到一些夺目的特性：简洁性与表现力、模式匹配的力量以及函数值/闭包和并发。此外，我们 还将学习 Scala 对 XML 处理的支持—一个在构建企业级应用时会极大受益的特性。 ①\n从 Scala 2.11.x 版本开始，对 XML 的支持已经被移到了单独的模块中。——译者注","title":"第15章——使用Scala创建应用程序"},{"location":"/chapter-15/index.html#15-1-获取用户输入","text":"UsingScala/ConsoleInput.scala\nimport scala.io._\n\nprint(\"Please enter a ticker symbol:\")\nval symbol = StdIn.readLine()\nprintln(s\"OK, got it, you own $symbol\")\n运行结果\nPlease enter a ticker symbol:OK, got it, you own AAPL","title":"15.1 获取用户输入"},{"location":"/chapter-15/index.html#15-2-读写文件","text":"UsingScala/WriteToFile.scala\nimport java.io._\n\nval writer = new PrintWriter(new File(\"symbols.txt\"))\nwriter.write(\"AAPL\")\nwriter.close()\nprintln(scala.io.Source.fromFile(\"symbols.txt\").mkString)\nUsingScala/ReadingFile.scala\nimport scala.io.Source\n\nprintln(\"*** The content of the file you read is:\")\nSource.fromFile(\"ReadingFile.scala\").foreach { print }\n运行结果\n*** The content of the file you read is:\nimport scala.io.Source\n\nprintln(\"*** The content of the file you read is:\")\nSource.fromFile(\"ReadingFile.scala\").foreach { print }\nUsingScala/ReadingURL.scala\nimport scala.io.Source\nimport java.net.URL\n\nval source = Source.fromURL(new URL(\"http://localhost\"))\n\nprintln(s\"What's Source?: $source\")\nprintln(s\"Raw String: ${source.mkString}\")\n运行结果\nWhat's Source?: non-empty iterator\nRaw String: <html><body><h1>It works!</h1></body></html>","title":"15.2 读写文件"},{"location":"/chapter-15/index.html#15-3-xml-作为一等公民","text":"UsingScala/UseXML.scala\nval xmlFragment =\n  <symbols>\n    <symbol ticker=\"AAPL\"><units>200</units></symbol>\n    <symbol ticker=\"IBM\"><units>215</units></symbol>\n  </symbols>\n\nprintln(xmlFragment)\nprintln(xmlFragment.getClass)\n运行结果\n<symbols>\n  <symbol ticker=\"AAPL\"><units>200</units></symbol>\n  <symbol ticker=\"IBM\"><units>215</units></symbol>\n</symbols>\nclass scala.xml.Elem\nUsingScala/UseXML.scala\nvar symbolNodes = xmlFragment \\ \"symbol\"\nsymbolNodes.foreach(println)\nprintln(symbolNodes.getClass)\n运行结果\n<symbol ticker=\"AAPL\"><units>200</units></symbol>\n<symbol ticker=\"IBM\"><units>215</units></symbol>\nclass scala.xml.NodeSeq$$anon$1\nUsingScala/UseXML.scala\nvar unitsNodes = xmlFragment \\\\ \"units\"\nunitsNodes.foreach(println)\nprintln(unitsNodes.getClass)\nprintln(unitsNodes.head.text)\n运行结果\n<units>200</units>\n<units>215</units>\nclass scala.xml.NodeSeq$$anon$1\n200\nUsingScala/UseXML.scala\nunitsNodes.head match {\n  case <units>{numberOfUnits}</units> => println(s\"Units: $numberOfUnits\")\n}\n运行结果\nUnits: 200\nUsingScala/UseXML.scala\nprintln(\"Ticker\\tUnits\")\nxmlFragment match {\n  case <symbols>{symbolNodes @ _*}</symbols> =>\n    for (symbolNode @ <symbol>{_*}</symbol> <- symbolNodes) {\n      println(\"%-7s %s\".format(symbolNode \\ \"@ticker\", (symbolNode \\ \"units\").text))\n    }\n}\n运行结果\nTicker\tUnits\nAAPL    200\nIBM     215","title":"15.3 XML 作为一等公民"},{"location":"/chapter-15/index.html#15-4-读写-xml","text":"stocks.xml\n<symbols>\n  <symbol ticker=\"AAPL\"><units>200</units></symbol>\n  <symbol ticker=\"ADBE\"><units>125</units></symbol>\n  <symbol ticker=\"ALU\"><units>150</units></symbol>\n  <symbol ticker=\"AMD\"><units>150</units></symbol>\n  <symbol ticker=\"CSCO\"><units>250</units></symbol>\n  <symbol ticker=\"HPQ\"><units>225</units></symbol>\n  <symbol ticker=\"IBM\"><units>215</units></symbol>\n  <symbol ticker=\"INTC\"><units>160</units></symbol>\n  <symbol ticker=\"MSFT\"><units>190</units></symbol>\n  <symbol ticker=\"NSM\"><units>200</units></symbol>\n  <symbol ticker=\"ORCL\"><units>200</units></symbol>\n  <symbol ticker=\"SYMC\"><units>230</units></symbol>\n  <symbol ticker=\"TXN\"><units>190</units></symbol>\n  <symbol ticker=\"VRSN\"><units>200</units></symbol>\n  <symbol ticker=\"XRX\"><units>240</units></symbol>\n</symbols>\nUsingScala/ReadWriteXML.scala\nimport scala.xml._\n\nval stocksAndUnits = XML.load(\"stocks.xml\")\nprintln(stocksAndUnits.getClass)\nprintln(s\"File has ${(stocksAndUnits \\\\ \"symbol\").size} symbol elements\")\n运行结果\nclass scala.xml.Elem\nFile has 15 symbol elements\nUsingScala/ReadWriteXML.scala\nval stocksAndUnitsMap =\n  (Map[String, Int]() /: (stocksAndUnits \\ \"symbol\")) { (map, symbolNode) =>\n    val ticker = (symbolNode \\ \"@ticker\").toString\n    val units = (symbolNode \\ \"units\").text.toInt\n    map + (ticker -> units) //return new map, with one additional entry\n  }\n\nprintln(s\"Number of symbol elements found is ${stocksAndUnitsMap.size}\")\n运行结果\nNumber of symbol elements found is 15\nUsingScala/ReadWriteXML.scala\nval updatedStocksAndUnitsXML =\n  <symbols>\n    {stocksAndUnitsMap.map(updateUnitsAndCreateXML)}\n  </symbols>\n\ndef updateUnitsAndCreateXML(element: (String, Int)) = {\n  val (ticker, units) = element\n  <symbol ticker={ticker}>\n    <units>{units + 1}</units>\n  </symbol>\n}\n\nXML.save(\"stocks2.xml\", updatedStocksAndUnitsXML)\n\nval elementsCount = (XML.load(\"stocks2.xml\") \\\\ \"symbol\").size\nprintln(s\"Saved file has $elementsCount symbol elements\")\n运行结果\nSaved file has 15 symbol elements\n示例文件\nDate,Open,High,Low,Close,Volume,Adj Close\n2015-03-20,561.65,561.72,559.05,560.36,2585800,560.36\n2015-03-19,559.39,560.80,556.15,557.99,1191100,557.99\n2015-03-18,552.50,559.78,547.00,559.50,2124400,559.50\n...","title":"15.4 读写 XML"},{"location":"/chapter-15/index.html#15-5-从-web-获取股票价格","text":"UsingScala/StockPriceFinder.scala\nobject StockPriceFinder {\n  import scala.io.Source\n\n  case class Record(year: Int, month: Int, date: Int, closePrice: BigDecimal)\n\n  def getLatestClosingPrice(symbol: String): BigDecimal = {\n    val url = s\"https://raw.githubusercontent.com/ReactivePlatform/\" +\n      s\"Pragmatic-Scala-StaticResources/master/src/main/resources/\" +\n      s\"stocks/daily/daily_$symbol.csv\"\n\n    val data = Source.fromURL(url).mkString\n    val latestClosePrize = data\n      .split(\"\\n\")\n      .slice(1, 2)\n      .map(record => {\n        val Array(timestamp, open, high, low, close, volume) = record.split(\",\")\n        val Array(year, month, date) = timestamp.split(\"-\")\n        Record(year.toInt, month.toInt, date.toInt, BigDecimal(close.trim))\n      })\n      .map(_.closePrice)\n      .head\n    latestClosePrize\n  }\n\n  def getTickersAndUnits: Map[String, Int] = {\n    val classLoader = this.getClass.getClassLoader\n    val stocksXMLInputStream = classLoader.getResourceAsStream(\"stocks.xml\")\n    //或者来自于文件\n    val stocksAndUnitsXML = scala.xml.XML.load(stocksXMLInputStream)\n    (Map[String, Int]() /: (stocksAndUnitsXML \\ \"symbol\")) { (map, symbolNode) =>\n      val ticker = (symbolNode \\ \"@ticker\").toString\n      val units = (symbolNode \\ \"units\").text.toInt\n      map + (ticker -> units)\n    }\n  }\n}\nUsingScala/FindTotalWorthSequential.scala\nobject FindTotalWorthSequential extends App {\n\n  val symbolsAndUnits = StockPriceFinder.getTickersAndUnits\n\n  println(\"Ticker  Units  Closing Price($) Total Value($)\")\n\n  val startTime = System.nanoTime()\n  val valuesAndWorth = symbolsAndUnits.keys.map { symbol =>\n    val units = symbolsAndUnits(symbol)\n    val latestClosingPrice = StockPriceFinder.getLatestClosingPrice(symbol)\n    val value = units * latestClosingPrice\n\n    (symbol, units, latestClosingPrice, value)\n  }\n\n  val netWorth = (BigDecimal(0.0d) /: valuesAndWorth) { (worth, valueAndWorth) =>\n    val (_, _, _, value) = valueAndWorth\n    worth + value\n  }\n  val endTime = System.nanoTime()\n\n  valuesAndWorth.toList.sortBy(_._1).foreach { valueAndWorth =>\n    val (symbol, units, latestClosingPrice, value) = valueAndWorth\n    println(f\"$symbol%7s  $units%5d  $latestClosingPrice%15.2f  $value%.2f\")\n  }\n\n  println(f\"The total value of your investments is $$$netWorth%.2f\")\n  println(f\"Took ${(endTime - startTime) / 1000000000.0}%.2f  seconds\")\n}\n运行结果\nTicker  Units  Closing Price($) Total Value($)\n   AAPL    200           125.90  25180.00\n   ADBE    125            77.36  9670.00\n    ALU    150             3.84  576.00\n    AMD    150             2.80  420.00\n   CSCO    250            28.44  7110.00\n    HPQ    225            33.28  7488.00\n    IBM    215           162.88  35019.20\n   INTC    160            31.31  5009.60\n   MSFT    190            42.88  8147.20\n    NSM    200            29.94  5988.00\n   ORCL    200            44.41  8882.00\n   SYMC    230            24.38  5607.40\n    TXN    190            59.28  11263.20\n   VRSN    200            64.75  12950.00\n    XRX    240            13.18  3163.20\nThe total value of your investments is $146473.80\nTook 11.13  seconds","title":"15.5 从 Web 获取股票价格"},{"location":"/chapter-15/index.html#15-6-编写并发的资产净值应用程序","text":"UsingScala/FindTotalWorthConcurrent.scala\nimport scala.collection.parallel.CollectionConverters._\nval valuesAndWorth = symbolsAndUnits.keys.par.map { symbol =>\n运行结果\nTicker  Units  Closing Price($) Total Value($)\n   AAPL    200           125.90  25180.00\n   ADBE    125            77.36  9670.00\n    ALU    150             3.84  576.00\n    AMD    150             2.80  420.00\n   CSCO    250            28.44  7110.00\n    HPQ    225            33.28  7488.00\n    IBM    215           162.88  35019.20\n   INTC    160            31.31  5009.60\n   MSFT    190            42.88  8147.20\n    NSM    200            29.94  5988.00\n   ORCL    200            44.41  8882.00\n   SYMC    230            24.38  5607.40\n    TXN    190            59.28  11263.20\n   VRSN    200            64.75  12950.00\n    XRX    240            13.18  3163.20\nThe total value of your investments is $146473.80\nTook 1.98  seconds","title":"15.6 编写并发的资产净值应用程序"},{"location":"/chapter-16/index.html","text":"","title":"第16章——单元测试 ·"},{"location":"/chapter-16/index.html#第16章-单元测试","text":"代码将总是按照被编写的行为运行—单元测试将确保它做的确实符合编写者的本意。 在开发应用程序的过程中，单元测试还有助于确保代码行为持续符合预期。","title":"第16章——单元测试"},{"location":"/chapter-16/index.html#16-1-使用-junit","text":"UnitTesting/UsingJUnit.scala\nimport java.util\n\nimport org.junit.Assert._\nimport org.junit.Test\n\nclass UsingJUnit {\n  @Test\n  def listAdd(): Unit = {\n    val list = new util.ArrayList[String]\n    list.add(\"Milk\")\n    list.add(\"Sugar\")\n    assertEquals(2, list.size)\n  }\n}\n执行命令\nscalac -d classes -classpath $JUNIT_JAR:$HAMCREST_JAR UsingJUnit.scala\njava -classpath $SCALALIBRARY:$JUNIT_JAR:$HAMCREST_JAR:classes \\\n  org.junit.runner.JUnitCore UsingJUnit\n运行结果\nJUnit version 4.12\n.\nTime: 0.003\n\nOK (1 test)","title":"16.1 使用 JUnit"},{"location":"/chapter-16/index.html#16-2-使用-scalatest","text":"UnitTesting/UsingScalaTest.scala\nimport java.util\nimport org.scalatest._\n\nclass UsingScalaTest extends FlatSpec with Matchers {\n  trait EmptyArrayList {\n    val list = new util.ArrayList[String]\n  }\n\n  \"a list\" should \"be empty on create\" in new EmptyArrayList {\n    list.size should be(0)\n  }\n\n  \"a list\" should \"increase in size upon add\" in new EmptyArrayList {\n    list.add(\"Milk\")\n    list.add(\"Sugar\")\n\n    list.size should be(2)\n  }\n}\n执行命令\nscalac -d classes -classpath $SCALA_TEST_JAR UsingScalaTest.scala\nscala -classpath $SCALA_TEST_JAR:classes org.scalatest.run UsingScalaTest\n运行结果\nRun starting. Expected test count is: 2\nUsingScalaTest:\na list\n- should be empty on create\na list\n- should increase in size upon add\nRun completed in 181 milliseconds.\nTotal number of tests run: 2\nSuites: completed 1, aborted 0\nTests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0\nAll tests passed.","title":"16.2 使用 ScalaTest"},{"location":"/chapter-16/index.html#16-3-使用-mockito","text":"UnitTesting/WordScorerTest.scala (withoutmock)\nimport org.scalatest.{ FlatSpec, Matchers }\n\nclass WordScorerTest extends FlatSpec with Matchers {\n\n  def withWordScorer(test: WordScorer => Unit): Unit = {\n    val wordScorer = new WordScorer()\n\n    test(wordScorer)\n  }\n\n  \"score\" should \"return 0 for an empty word\" in {\n    withWordScorer { wordScorer =>\n      wordScorer.score(\"\") should be(0)\n    }\n  }\n\n  \"score\" should \"return 2 for word with two vowels\" in {\n    withWordScorer { _.score(\"ai\") should be(2) }\n  }\n\n  \"score\" should \"return 8 for word with four consonants\" in {\n    withWordScorer { _.score(\"myth\") should be(8) }\n  }\n\n  \"score\" should \"return 7 for word with a vowel and three consonants\" in {\n    withWordScorer { _.score(\"that\") should be(7) }\n  }\n}\nUnitTesting/WordScorer.scala (withoutmock)\nclass WordScorer() {\n  private val VOWELS = List('a', 'e', 'i', 'o', 'u')\n\n  def score(word: String): Int = {\n    (0 /: word) { (total, letter) =>\n      total + (if (VOWELS.contains(letter)) 1 else 2)\n    }\n  }\n}\n执行命令\nscalac -d classes -classpath $SCALA_TEST_JAR \\\n  WordScorer.scala WordScorerTest.scala\nscala -classpath $SCALA_TEST_JAR:classes org.scalatest.run WordScorerTest\n运行结果\nRun starting. Expected test count is: 4\nWordScorerTest:\nscore\n- should return 0 for an empty word\nscore\n- should return 2 for word with two vowels\nscore\n- should return 8 for word with four consonants\nscore\n- should return 7 for word that with a vowel and three consonants\nRun completed in 181 milliseconds.\nTotal number of tests run: 4\nSuites: completed 1, aborted 0\nTests: succeeded 4, failed 0, canceled 0, ignored 0, pending 0\nAll tests passed.\nUnitTesting/SpellChecker.scala (withmock)\ntrait SpellChecker {\n  def isCorrect(word: String): Boolean\n}\nUnitTesting/WordScorerTest.scala (withmock)\nimport org.scalatest.{ FlatSpec, Matchers }\nimport org.mockito.Mockito._\nimport org.mockito.ArgumentMatchers.anyString\n\nclass WordScorerTest extends FlatSpec with Matchers {\n\n  def withWordScorer(test: WordScorer => Unit): Boolean = {\n    val spellChecker = mock(classOf[SpellChecker])\n    when(spellChecker.isCorrect(anyString)).thenReturn(true)\n    val wordScorer = new WordScorer(spellChecker)\n\n    test(wordScorer)\n\n    verify(spellChecker, times(1)).isCorrect(anyString())\n  }\n\n  //No change to the tests, same as in the previous version\n  \"score\" should \"return 0 for an empty word\" in {\n    withWordScorer { wordScorer =>\n      wordScorer.score(\"\") should be(0)\n    }\n  }\n\n  \"score\" should \"return 2 for word with two vowels\" in {\n    withWordScorer { _.score(\"ai\") should be(2) }\n  }\n\n  \"score\" should \"return 8 for word with four consonants\" in {\n    withWordScorer { _.score(\"myth\") should be(8) }\n  }\n\n  \"score\" should \"return 7 for word that with a vowel and three consonants\" in {\n    withWordScorer { _.score(\"that\") should be(7) }\n  }\n\n}\nUnitTesting/WordScorer.scala (withmock)\nclass WordScorer(val spellChecker: SpellChecker) {\n  private val VOWELS = List('a', 'e', 'i', 'o', 'u')\n\n  def score(word: String): Int = {\n    spellChecker.isCorrect(word)\n    (0 /: word) { (total, letter) =>\n      total + (if (VOWELS.contains(letter)) 1 else 2)\n    }\n  }\n}\n执行命令\nscalac -d classes -classpath $SCALA_TEST_JAR:$MOCKITO_JAR \\\n  WordScorer.scala SpellChecker.scala WordScorerTest.scala\nscala -classpath $SCALA_TEST_JAR::$MOCKITO_JAR:classes \\\n  org.scalatest.run WordScorerTest\n运行结果\nRun starting. Expected test count is: 4\nWordScorerTest:\nscore\n- should return 0 for an empty word\nscore\n- should return 2 for word with two vowels\nscore\n- should return 8 for word with four consonants\nscore\n- should return 7 for word that with a vowel and three consonants\nRun completed in 316 milliseconds.\nTotal number of tests run: 4\nSuites: completed 1, aborted 0\nTests: succeeded 4, failed 0, canceled 0, ignored 0, pending 0\nAll tests passed.\nUnitTesting/WordScorerTest.scala (withmock2)\n\"score\" should \"return 0 for word with incorrect spelling\" in {\n  val spellChecker = mock(classOf[SpellChecker])\n  when(spellChecker.isCorrect(anyString)).thenReturn(false)\n  val wordScorer = new WordScorer(spellChecker)\n\n  wordScorer.score(\"aoe\") should be(0)\n  verify(spellChecker, times(1)).isCorrect(anyString())\n}\nUnitTesting/WordScorer.scala (withmock2)\ndef score(word: String): Int = {\n  if (spellChecker.isCorrect(word))\n    (0 /: word) { (total, letter) =>\n      total + (if (VOWELS.contains(letter)) 1 else 2)\n    } else\n    0\n}\n运行结果\nRun starting. Expected test count is: 5\nWordScorerTest:\nscore\n- should return 0 for an empty word\nscore\n- should return 2 for word with two vowels\nscore\n- should return 8 for word with four consonants\nscore\n- should return 7 for word that with a vowel and three consonants\nscore\n- should return 0 for word with incorrect spelling\nRun completed in 208 milliseconds.\nTotal number of tests run: 5\nSuites: completed 1, aborted 0\nTests: succeeded 5, failed 0, canceled 0, ignored 0, pending 0\nAll tests passed.","title":"16.3 使用 Mockito"},{"location":"/refs/references.html","text":"","title":"参考书目 ·"},{"location":"/refs/references.html#参考书目","text":"[AS96] Harold Abelson and Gerald Jay Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, 2nd, 1996. ①\n[Bec96] Kent Beck. Smalltalk Best Practice Patterns. Prentice Hall, Englewood Cliffs, NJ, 1996. ② [Blo08] Joshua Bloch. Effective Java. Addison-Wesley, Reading, MA, 2008.\n[Fri97] Jeffrey E. F. Friedl. Mastering Regular Expressions. O’Reilly & Associates, Inc., Sebastopol, CA, 1997. ③ [GHJV95] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns:\nElements of Reusable Object-Oriented Software. Addison-Wesley, Reading, MA, 1995. ④ [Goe06] Brian Goetz. Java Concurrency in Practice. Addison-Wesley, Reading, MA, 2006. ⑤ [HT00] Andrew Hunt and David Thomas. The Pragmatic Programmer: From Journeyman to\nMaster. Addison-Wesley, Reading, MA, 2000. ⑥\n[Sub11] Venkat Subramaniam. Programming Concurrency on the JVM. The Pragmatic Bookshelf,\nRaleigh, NC, and Dallas, TX, 2011.\n[Sub14] Venkat Subramaniam. Functional Programming in Java. The Pragmatic Bookshelf,\nRaleigh, NC, and Dallas, TX, 2014.\n中文版书名为《计算机结构和解释》。—译者注 中文版书名为《Smalltalk 最佳实践模式》。—译者注 中文版书名为《精通正则表达式》。—译者注 中文版书名为《设计模式：可复用面向对象软件的基础》。—译者注 中文版书名为《Java 并发编程实战》。—译者注 中文版书名为《程序员修炼之道：从小工到专家》。—译者注","title":"参考书目"},{"location":"/extras.html","text":"","title":"额外指引 ·"},{"location":"/extras.html#额外指引","text":"Netty In Action In Scala","title":"额外指引"},{"location":"/errata.html","text":"","title":"勘误 ·"},{"location":"/errata.html#勘误","text":"TODO","title":"勘误"}]}